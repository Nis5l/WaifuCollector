FUNCTION  coc#float#create_float_win()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 66
Called 4 times
Total time:   0.003111
 Self time:   0.000425

count  total (s)   self (s)
    4              0.000009   let lines = get(a:config, 'lines', v:null)
    4   0.000245   0.000027   let bufnr = coc#float#create_buf(a:bufnr, lines, 'hide')
                              " use exists
    4   0.000034   0.000015   if a:winid && coc#float#valid(a:winid)
    3              0.000002     if s:is_vim
                                  let [line, col] = s:popup_position(a:config)
                                  let opts = { 'firstline': 1, 'line': line, 'col': col, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'cursorline': get(a:config, 'cursorline', 0), 'title': get(a:config, 'title', ''), }
                                  if !s:empty_border(get(a:config, 'border', []))
                                    let opts['border'] = a:config['border']
                                  endif
                                  call popup_setoptions(a:winid, opts)
                                  call coc#float#vim_buttons(a:winid, a:config)
                                  return [a:winid, winbufnr(a:winid)]
    3              0.000001     else
    3   0.000360   0.000019       let config = s:convert_config_nvim(a:config)
    3              0.000030       call nvim_win_set_buf(a:winid, bufnr)
    3              0.000015       call nvim_win_set_config(a:winid, config)
    3              0.000016       call nvim_win_set_cursor(a:winid, [1, 0])
    3   0.001723   0.000019       call coc#float#nvim_create_related(a:winid, config, a:config)
    3              0.000005       return [a:winid, bufnr]
                                endif
    1              0.000000   endif
    1              0.000001   let winid = 0
    1              0.000001   if s:is_vim
                                let [line, col] = s:popup_position(a:config)
                                let title = get(a:config, 'title', '')
                                let buttons = get(a:config, 'buttons', [])
                                let hlgroup = get(a:config, 'highlight',  'CocFloating')
                                let opts = { 'title': title, 'line': line, 'col': col, 'fixed': 1, 'padding': empty(title) ?  [0, 1, 0, 1] : [0, 0, 0, 0], 'borderchars': s:borderchars, 'highlight': hlgroup, 'cursorline': get(a:config, 'cursorline', 0), 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'] }
                                if get(a:config, 'close', 0)
                                  let opts['close'] = 'button'
                                endif
                                if !empty(get(a:config, 'borderhighlight', []))
                                  let opts['borderhighlight'] = map(a:config['borderhighlight'], 'coc#highlight#compose_hlgroup(v:val,"'.hlgroup.'")')
                                endif
                                if !s:empty_border(get(a:config, 'border', []))
                                  let opts['border'] = a:config['border']
                                endif
                                let winid = popup_create(bufnr, opts)
                                if winid == 0
                                  return []
                                endif
                                call coc#float#vim_buttons(winid, a:config)
                                if has("patch-8.1.2281")
                                  call setwinvar(winid, '&showbreak', 'NONE')
                                endif
    1              0.000000   else
    1   0.000123   0.000007     let config = s:convert_config_nvim(a:config)
    1              0.000061     let winid = nvim_open_win(bufnr, 0, config)
    1              0.000001     if winid == 0
                                  return []
    1              0.000000     endif
    1              0.000002     let hlgroup = get(a:config, 'highlight', 'CocFloating')
    1              0.000014     call setwinvar(winid, '&winhl', 'Normal:'.hlgroup.',NormalNC:'.hlgroup.',FoldColumn:'.hlgroup)
    1              0.000004     call setwinvar(winid, '&signcolumn', 'no')
                                " cursorline highlight not work on old neovim
    1              0.000003     call setwinvar(winid, '&cursorline', 0)
    1              0.000003     call setwinvar(winid, 'border', get(a:config, 'border', []))
                                " no left border
    1   0.000009   0.000007     if s:empty_border(get(a:config, 'border', [])) || a:config['border'][3] == 0
    1              0.000004       call setwinvar(winid, '&foldcolumn', 1)
    1              0.000000     endif
    1              0.000009     call nvim_win_set_cursor(winid, [1, 0])
    1   0.000285   0.000007     call coc#float#nvim_create_related(winid, config, a:config)
    1              0.000000   endif
    1              0.000002   if get(a:config, 'autohide', 0)
    1              0.000002     call setwinvar(winid, 'autohide', 1)
    1              0.000000   endif
    1              0.000003   if s:is_vim || has('nvim-0.5.0')
                                call setwinvar(winid, '&scrolloff', 0)
    1              0.000000   endif
    1              0.000002   call setwinvar(winid, 'float', 1)
    1              0.000003   call setwinvar(winid, '&list', 0)
    1              0.000002   call setwinvar(winid, '&number', 0)
    1              0.000002   call setwinvar(winid, '&relativenumber', 0)
    1              0.000002   call setwinvar(winid, '&cursorcolumn', 0)
    1              0.000003   call setwinvar(winid, '&colorcolumn', 0)
    1              0.000002   call setwinvar(winid, '&wrap', 1)
    1              0.000002   call setwinvar(winid, '&linebreak', 1)
    1              0.000002   call setwinvar(winid, '&conceallevel', 2)
    1              0.000003   let g:coc_last_float_win = winid
    1   0.000012   0.000006   call coc#util#do_autocmd('CocOpenFloat')
    1              0.000001   return [winid, bufnr]

FUNCTION  coc#client#get_channel()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 141
Called 163 times
Total time:   0.000697
 Self time:   0.000697

count  total (s)   self (s)
  163              0.000145   if s:is_vim
                                return a:client['channel']
  163              0.000051   endif
  163              0.000182   return a:client['chan_id']

FUNCTION  3()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 47
Called 6150 times
Total time:   0.239880
 Self time:   0.167120

count  total (s)   self (s)
 6150   0.075671   0.026950     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
 6150              0.003708     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
 6150              0.001660     endif
                            
 6150              0.006965     let self._bookmarkNames = []
 6150   0.044864   0.020826     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
 6150              0.003472     endfor
 6150              0.010251     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
 6150              0.001606     endif
                            
 6150              0.003497     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
 6150              0.001515     endif
                            
 6150              0.003374     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
 6150              0.001592     endif

FUNCTION  gitgutter#async#execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 16
Called 4 times
Total time:   0.019029
 Self time:   0.018838

count  total (s)   self (s)
    4   0.000177   0.000029   call gitgutter#debug#log('[async] '.a:cmd)
                            
    4              0.000022   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    4   0.000086   0.000044   let command = s:build_command(a:cmd)
                            
    4              0.000006   if has('nvim')
    4              0.018579     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    4              0.000004   endif

FUNCTION  <SNR>130_is_modified()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 281
Called 17 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
   17              0.000030   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  coc#highlight#add_highlight()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 41
Called 5 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    5              0.000008   if has('nvim')
    5              0.000053     call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
    5              0.000002   endif

FUNCTION  coc#util#do_autocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 708
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000018   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
    3              0.000001   endif

FUNCTION  <SNR>22_Autocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 228
Called 155 times
Total time:   0.012145
 Self time:   0.001463

count  total (s)   self (s)
  155              0.000241   if !g:coc_workspace_initialized
                                return
  155              0.000058   endif
  155   0.011570   0.000888   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  GetJsxIndent()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\after\indent\jsx.vim line 28
Called 1 time
Total time:   0.001122
 Self time:   0.000032

count  total (s)   self (s)
    1   0.001120   0.000030   return jsx_pretty#indent#get(function('GetJavascriptIndent'))

FUNCTION  <SNR>77_ProcessTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1539
Called 2 times
Total time:   0.002298
 Self time:   0.000595

count  total (s)   self (s)
    2              0.000002     if a:is_split
                                    let taginfo = tagbar#prototypes#splittag#new(a:name)
    2              0.000001     else
    2   0.001288   0.000021         let taginfo = tagbar#prototypes#normaltag#new(a:name)
    2              0.000002     endif
                            
    2              0.000006     let taginfo.file    = a:filename
    2              0.000006     let taginfo.pattern = a:pattern
    2              0.000061     call extend(taginfo.fields, a:fields)
                            
                                " Needed for jsctags
    2              0.000007     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
    2              0.000001     endif
                                " Do some sanity checking in case ctags reports invalid line numbers
    2              0.000004     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
    2              0.000001     endif
                            
                                " Make sure our 'end' is valid
    2              0.000008     if taginfo.fields.end < taginfo.fields.line
    2   0.000058   0.000034         if a:typeinfo.getKind(taginfo.fields.kind).stl
                                        " the config indicates this is a scoped kind due to 'stl', but we
                                        " don't have scope vars, assume scope goes to end of file. This
                                        " can also be the case for exhuberant ctags which doesn't support
                                        " the --fields=e option.
                                        " When we call the GetNearbyTag(), it will look up for the nearest
                                        " tag, so if we have multiples that have scope to the end of the
                                        " file it will still only grab the first one above the current line
    2              0.000007             let taginfo.fields.end = line('$')
                                    else
                                        let taginfo.fields.end = taginfo.fields.line
    2              0.000002         endif
    2              0.000001     endif
                            
    2              0.000006     if !has_key(taginfo.fields, 'kind')
                                    call tagbar#debug#log( "Warning: No 'kind' field found for tag " . a:name[0] . '!')
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . a:name[0] . '!' . " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
    2              0.000002     endif
                            
    2              0.000006     let taginfo.fileinfo = a:fileinfo
    2              0.000005     let taginfo.typeinfo = a:typeinfo
                            
    2              0.000010     let a:fileinfo.fline[taginfo.fields.line] = taginfo
                            
    2              0.000007     if has_key(taginfo.fields, 'typeref')
                                    let typeref = taginfo.fields.typeref
                                    let delimit = stridx(typeref, ':')
                                    let key = strpart(typeref, 0, delimit)
                                    if key ==# 'typename'
                                        let taginfo.data_type = substitute(strpart(typeref, delimit + 1), '\t', '', 'g')
                                    else
                                        let taginfo.data_type = key
                                    endif
    2              0.000001     endif
                            
                                " If this filetype doesn't have any scope information then we can stop
                                " here after adding the tag to the list
    2              0.000007     if !has_key(a:typeinfo, 'scope2kind')
                                    call a:fileinfo.addTag(taginfo)
                                    return
    2              0.000001     endif
                            
                            
                                " Make some information easier accessible
    6              0.000020     for scope in keys(a:typeinfo.scope2kind)
    4              0.000014         if has_key(taginfo.fields, scope)
                                        let taginfo.scope = scope
                                        let taginfo.path  = taginfo.fields[scope]
                            
                                        let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
                                        break
    4              0.000003         endif
    6              0.000007     endfor
    2              0.000023     let pathlist = split(taginfo.path, '\V' . escape(a:typeinfo.sro, '\'))
    2              0.000007     let taginfo.depth = len(pathlist)
                            
                                " Needed for folding
    2              0.000002     try
    2   0.000128   0.000031         call taginfo.initFoldState(s:known_files)
                                catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call tagbar#debug#log('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
    2              0.000002     endtry
                            
    2   0.000349   0.000035     call s:add_tag_recursive({}, taginfo, pathlist)

FUNCTION  coc#util#get_format_opts()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 914
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000014   if a:bufnr && bufloaded(a:bufnr)
    3              0.000013     let tabsize = getbufvar(a:bufnr, '&shiftwidth')
    3              0.000003     if tabsize == 0
                                  let tabsize = getbufvar(a:bufnr, '&tabstop')
    3              0.000001     endif
    3              0.000009     return [tabsize, getbufvar(a:bufnr, '&expandtab')]
                              endif
                              let tabsize = &shiftwidth == 0 ? &tabstop : &shiftwidth
                              return [tabsize, &expandtab]

FUNCTION  coc#highlight#compose_hlgroup()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 131
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000010   let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
    4              0.000005   if a:fgGroup == a:bgGroup
    4              0.000003     return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup

FUNCTION  <SNR>125_add_snr()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 240
Called 38 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
   38              0.000102     if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
   38              0.000024     endif
   38              0.000082     return s:snr . a:funcname

FUNCTION  <SNR>123_getTagsByName()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 85
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010     return get(self._tagdict, a:tagname, [])

FUNCTION  coc#float#cursor_relative()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1382
Called 4 times
Total time:   0.000198
 Self time:   0.000122

count  total (s)   self (s)
    4   0.000078   0.000045   if !coc#float#valid(a:winid)
                                return v:null
    4              0.000001   endif
    4              0.000008   let winid = win_getid()
    4              0.000003   if winid == a:winid
                                return v:null
    4              0.000001   endif
    4   0.000064   0.000020   let [cursorLine, cursorCol] = coc#util#cursor_pos()
    4              0.000006   if has('nvim')
    4              0.000011     let [row, col] = nvim_win_get_position(a:winid)
    4              0.000011     return {'row' : row - cursorLine, 'col' : col - cursorCol}
                              endif
                              let pos = popup_getpos(a:winid)
                              return {'row' : pos['line'] - cursorLine - 1, 'col' : pos['col'] - cursorCol - 1}

FUNCTION  <SNR>58_on_stderr_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 66
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000009   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    4              0.000002   endif

FUNCTION  <SNR>130_process_modified()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 310
Called 17 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   17              0.000015   let offset = 0
   34              0.000034   while offset < a:to_count
   17              0.000023     let line_number = a:to_line + offset
   17              0.000037     call add(a:modifications, [line_number, 'modified'])
   17              0.000016     let offset += 1
   34              0.000018   endwhile

FUNCTION  <SNR>103_IsContOne()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 297
Called 1 time
Total time:   0.000069
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000005   let [l:num, pind] = b:js_cache[1] ? [b:js_cache[1], indent(b:js_cache[1]) + s:sw()] : [1,0]
    1              0.000003   let [ind, b_l] = [indent('.') + !a:cont, 0]
    1              0.000003   while line('.') > l:num && ind > pind || line('.') == l:num
    1   0.000047   0.000005     if indent('.') < ind && s:OneScope()
                                  let b_l += 1
    1              0.000002     elseif !a:cont || b_l || ind < indent(a:firstline)
    1              0.000000       break
                                else
                                  call cursor(0,1)
                                endif
                                let ind = min([ind, indent('.')])
                                if s:PreviousToken() is ''
                                  break
                                endif
    1              0.000001   endwhile
    1              0.000001   return b_l

FUNCTION  coc#_insert_key()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 49
Called 4 times
Total time:   0.000122
 Self time:   0.000086

count  total (s)   self (s)
    4              0.000031   if get(a:, 1, 1)
    4   0.000063   0.000026     call coc#_cancel()
    4              0.000002   endif
    4              0.000018   return "\<c-r>=coc#rpc#".a:method."('doKeymap', ['".a:key."'])\<CR>"

FUNCTION  nerdtree#slash()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\autoload\nerdtree.vim line 37
Called 12522 times
Total time:   0.133004
 Self time:   0.090088

count  total (s)   self (s)
12522   0.089162   0.046246     if nerdtree#runningWindows()
12522              0.021640         if exists('+shellslash') && &shellslash
 6150              0.003644             return '/'
 6372              0.001975         endif
                            
 6372              0.003412         return '\'
                                endif
                            
                                return '/'

FUNCTION  <SNR>132_handle_double_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 212
Called 4 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    4              0.000015   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    4              0.000001   endif
                            
    4              0.000003   return a:modified_lines

FUNCTION  <SNR>130_write_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 375
Called 4 times
Total time:   0.001769
 Self time:   0.001769

count  total (s)   self (s)
    4              0.000148   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    4              0.000010   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    4              0.000002   endif
                            
    4              0.000014   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    4              0.000001   endif
                            
    4              0.000007   if getbufvar(a:bufnr, '&endofline')
    4              0.000008     call add(bufcontents, '')
    4              0.000001   endif
                            
    4              0.000009   let fenc = getbufvar(a:bufnr, '&fileencoding')
    4              0.000005   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    4              0.000001   endif
                            
    4              0.000006   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    4              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    4              0.000002   try
    4              0.001461     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    4              0.000003   endtry

FUNCTION  <SNR>103_Balanced()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 247
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000001   let l:open = 0
    1              0.000006   let pos = match(a:line, '[][(){}]')
    1              0.000001   while pos != -1
                                if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
                                  let l:open += matchend(a:line[pos],'[[({]')
                                  if l:open < 0
                                    return
                                  endif
                                endif
                                let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ? '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
    1              0.000001   endwhile
    1              0.000001   return !l:open

FUNCTION  tagbar#prototypes#basetag#new()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 10
Called 2 times
Total time:   0.000986
 Self time:   0.000628

count  total (s)   self (s)
    2              0.000003     let newobj = {}
                            
    2              0.000004     let newobj.name          = a:name
    2              0.000003     let newobj.fields        = {}
    2              0.000003     let newobj.fields.line   = 0
    2              0.000003     let newobj.fields.column = 0
    2              0.000003     let newobj.fields.end    = 0
    2              0.000003     let newobj.prototype     = ''
    2              0.000004     let newobj.data_type     = ''
    2              0.000003     let newobj.path          = ''
    2              0.000003     let newobj.fullpath      = a:name
    2              0.000003     let newobj.depth         = 0
    2              0.000003     let newobj.parent        = {}
    2              0.000003     let newobj.tline         = -1
    2              0.000004     let newobj.fileinfo      = {}
    2              0.000003     let newobj.typeinfo      = {}
    2              0.000003     let newobj._childlist    = []
    2              0.000003     let newobj._childdict    = {}
                            
    2   0.000042   0.000025     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
    2   0.000057   0.000041     let newobj.isPseudoTag = function(s:add_snr('s:isPseudoTag'))
    2   0.000049   0.000029     let newobj.isSplitTag = function(s:add_snr('s:isSplitTag'))
    2   0.000048   0.000029     let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
    2   0.000051   0.000031     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
    2   0.000047   0.000027     let newobj.getDataType = function(s:add_snr('s:getDataType'))
    2   0.000047   0.000028     let newobj._getPrefix = function(s:add_snr('s:_getPrefix'))
    2   0.000049   0.000028     let newobj.initFoldState = function(s:add_snr('s:initFoldState'))
    2   0.000048   0.000029     let newobj.getClosedParentTline = function(s:add_snr('s:getClosedParentTline'))
    2   0.000047   0.000028     let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
    2   0.000047   0.000028     let newobj.isFolded = function(s:add_snr('s:isFolded'))
    2   0.000047   0.000028     let newobj.openFold = function(s:add_snr('s:openFold'))
    2   0.000046   0.000027     let newobj.closeFold = function(s:add_snr('s:closeFold'))
    2   0.000046   0.000027     let newobj.setFolded = function(s:add_snr('s:setFolded'))
    2   0.000047   0.000028     let newobj.openParents = function(s:add_snr('s:openParents'))
    2   0.000047   0.000028     let newobj.addChild = function(s:add_snr('s:addChild'))
    2   0.000048   0.000028     let newobj.getChildren = function(s:add_snr('s:getChildren'))
    2   0.000048   0.000029     let newobj.getChildrenByName = function(s:add_snr('s:getChildrenByName'))
    2   0.000047   0.000028     let newobj.removeChild = function(s:add_snr('s:removeChild'))
                            
    2              0.000003     return newobj

FUNCTION  coc#float#check_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 796
Called 5 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
    5              0.000006   let invalids = []
    5              0.000005   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
    5              0.000002   else
   20              0.000023     for i in range(1, winnr('$'))
   15              0.000029       let target = getwinvar(i, 'target_winid', 0)
   15              0.000017       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
   15              0.000023       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
   15              0.000004       endif
   20              0.000008     endfor
    5              0.000002   endif
    5              0.000005   for id in invalids
                                call coc#float#close(id)
    5              0.000002   endfor

FUNCTION  <SNR>125_isSplitTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 64
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return 0

FUNCTION  <SNR>134_syn_contains()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\comment.vim line 37
Called 57 times
Total time:   0.002143
 Self time:   0.002143

count  total (s)   self (s)
   57              0.001141   let stack = synstack(a:lnum, a:cnum)
   57              0.000794   let syn_names = map(stack, 'synIDattr(v:val, "name")')
   57              0.000148   return index(syn_names, a:syn_name) >= 0

FUNCTION  <SNR>89_newJob()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 30
Called 7 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    7              0.000157     return extend(deepcopy(s:Job), { 'name': a:name, 'opts': a:opts })

FUNCTION  jsx_pretty#indent#get()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 240
Called 1 time
Total time:   0.001090
 Self time:   0.000249

count  total (s)   self (s)
    1   0.000042   0.000022   let line = s:trim(getline(v:lnum))
    1   0.000047   0.000012   let start_syntax = s:start_syntax(v:lnum)
                            
    1   0.000018   0.000010   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
    1              0.000001   endif
                            
    1   0.000015   0.000008   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
    1              0.000001   endif
                            
    1   0.000020   0.000010   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
    1              0.000001   endif
                            
    1   0.000212   0.000017   let syntax_context = s:syntax_context(v:lnum)
                            
    1              0.000004   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
    1              0.000004   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
    1              0.000004   elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
    1              0.000003   elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
    1              0.000001   endif
                            
    1   0.000585   0.000018   return a:js_indent()

FUNCTION  coc#util#cursor()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 35
Called 22 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
   22              0.000254   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  coc#util#cursor_pos()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 157
Called 8 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    8              0.000026   let nr = winnr()
    8              0.000020   let [row, col] = win_screenpos(nr)
    8              0.000021   return [row + winline() - 2, col + wincol() - 2]

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 196
Called 4 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
    4              0.000567   let p = resolve(expand('#'.a:bufnr.':p'))
    4              0.000069   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    4              0.000015   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    4              0.000002   endif
    4              0.000008   return g:gitgutter_diff_base

FUNCTION  coc#float#create_buf()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1217
Called 8 times
Total time:   0.000696
 Self time:   0.000686

count  total (s)   self (s)
    8              0.000015   if a:bufnr > 0 && bufloaded(a:bufnr)
    4              0.000004     let bufnr = a:bufnr
    4              0.000002   else
    4              0.000002     if s:is_vim
                                  noa let bufnr = bufadd('')
                                  noa call bufload(bufnr)
                                  call setbufvar(bufnr, '&buflisted', 0)
    4              0.000001     else
    4              0.000237       noa let bufnr = nvim_create_buf(v:false, v:true)
    4              0.000003     endif
    4              0.000010     let bufhidden = get(a:, 2, 'wipe')
    4   0.000027   0.000022     call setbufvar(bufnr, '&buftype', 'nofile')
    4   0.000018   0.000017     call setbufvar(bufnr, '&bufhidden', bufhidden)
    4   0.000017   0.000015     call setbufvar(bufnr, '&swapfile', 0)
    4   0.000021   0.000020     call setbufvar(bufnr, '&undolevels', -1)
                                " neovim's bug
    4   0.000015   0.000013     call setbufvar(bufnr, '&modifiable', 1)
    8              0.000003   endif
    8              0.000016   let lines = get(a:, 1, v:null)
    8              0.000010   if type(lines) != 7
    8              0.000012     if has('nvim')
    8              0.000104       call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                else
                                  call deletebufline(bufnr, 1, '$')
                                  call setbufline(bufnr, 1, lines)
    8              0.000003     endif
    8              0.000002   endif
    8              0.000006   return bufnr

FUNCTION  <SNR>135_is_jsx_brace()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 81
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return a:syntax =~? 'jsxBraces'

FUNCTION  <SNR>58_on_stdout_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 56
Called 8 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
    8              0.000063   if empty(self.stdoutbuffer)
    4              0.000013     let self.stdoutbuffer = a:data
    4              0.000003   else
    4              0.000139     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    8              0.000005   endif

FUNCTION  <SNR>90_close_win()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1529
Called 1 time
Total time:   0.000312
 Self time:   0.000158

count  total (s)   self (s)
    1              0.000001   if a:winid == 0
                                return
    1              0.000000   endif
                              " vim not throw for none exists winid
    1              0.000001   if s:is_vim
                                call popup_close(a:winid)
    1              0.000000   else
    1              0.000002     if nvim_win_is_valid(a:winid)
    1   0.000304   0.000150       call nvim_win_close(a:winid, 1)
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  tagbar#sorting#sort()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\sorting.vim line 5
Called 1 time
Total time:   0.000142
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000003     let s:compare_typeinfo = a:compare_typeinfo
                            
    1              0.000004     let comparemethod = a:compareby ==# 'kind' ? 's:compare_by_kind' : 's:compare_by_line'
                            
    1   0.000074   0.000018     call sort(a:tags, comparemethod)
                            
    3              0.000005     for tag in a:tags
    2   0.000033   0.000028         if !empty(tag.getChildren())
                                        call tagbar#sorting#sort(tag.getChildren(), a:compareby, a:compare_typeinfo)
    2              0.000001         endif
    3              0.000003     endfor

FUNCTION  coc#compat#execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\compat.vim line 113
Called 4 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    4              0.000003   if s:is_vim
                                if !exists('*win_execute')
                                  throw 'win_execute function not exists, please upgrade your vim.'
                                endif
                                if type(a:command) == v:t_string
                                  keepalt call win_execute(a:winid, a:command)
                                elseif type(a:command) == v:t_list
                                  keepalt call win_execute(a:winid, join(a:command, "\n"))
                                endif
    4              0.000001   else
    4              0.000008     let curr = nvim_get_current_win()
    4              0.000023     noa keepalt call nvim_set_current_win(a:winid)
    4              0.000007     if type(a:command) == v:t_string
    4              0.000024       exec a:command
                                elseif type(a:command) == v:t_list
                                  exec join(a:command, "\n")
    4              0.000002     endif
    4              0.000025     noa keepalt call nvim_set_current_win(curr)
    4              0.000002   endif

FUNCTION  coc#rpc#request()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 88
Called 8 times
Total time:   0.032168
 Self time:   0.000109

count  total (s)   self (s)
    8   0.000081   0.000034   if !coc#rpc#ready()
                                return ''
    8              0.000002   endif
    8   0.032072   0.000060   return s:client['request'](a:method, a:args)

FUNCTION  coc#float#get_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1207
Called 128 times
Total time:   0.001675
 Self time:   0.001675

count  total (s)   self (s)
  136              0.000693   for winid in getwinvar(a:winid, 'related', [])
   11              0.000022     if getwinvar(winid, 'kind', '') ==# a:kind
    3              0.000002       return winid
    8              0.000003     endif
  133              0.000170   endfor
  125              0.000121   return 0

FUNCTION  <SNR>135_syntax_context()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 198
Called 1 time
Total time:   0.000195
 Self time:   0.000148

count  total (s)   self (s)
    1   0.000022   0.000012   let start_col = s:start_col(a:lnum)
    1   0.000051   0.000015   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
    1              0.000046   let start_syntax = syntax_stack[-1]
    1              0.000004   let reversed = reverse(syntax_stack)
    1              0.000001   let i = 0
                            
    1              0.000003   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
                                if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
                                endif
                            
                                if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
                                endif
                            
                                if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
                                endif
                            
                                let i = i + 1
    1              0.000004   endfor
                              
    1              0.000002   return 'Other'

FUNCTION  gitgutter#hunk#summary()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 20
Called 24 times
Total time:   0.000306
 Self time:   0.000147

count  total (s)   self (s)
   24   0.000299   0.000140   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>25_notify()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 181
Called 155 times
Total time:   0.007699
 Self time:   0.007032

count  total (s)   self (s)
  155   0.001634   0.000967   let channel = coc#client#get_channel(self)
  155              0.000182   if empty(channel)
                                return ''
  155              0.000043   endif
  155              0.000085   try
  155              0.000104     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  155              0.000076     else
  155              0.002117       call call('rpcnotify', [channel, a:method] + a:args)
  155              0.000072     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  155              0.000094   endtry

FUNCTION  <SNR>135_start_col()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 35
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000021   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  <SNR>124_add_snr()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim line 173
Called 10 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   10              0.000027     if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
   10              0.000006     endif
   10              0.000022     return s:snr . a:funcname

FUNCTION  301()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 63
Called 7 times
Total time:   0.005495
 Self time:   0.000098

count  total (s)   self (s)
    7              0.000019     if has_key(self.opts, 'on_success_cb')
    7   0.005468   0.000071         call call(self.opts.on_success_cb, [self])
    7              0.000003     endif

FUNCTION  <SNR>77_GetNearbyTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3129
Called 6 times
Total time:   0.001727
 Self time:   0.001623

count  total (s)   self (s)
    6              0.000004     if s:nearby_disabled
                                    return {}
    6              0.000002     endif
                            
    6   0.000128   0.000031     let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
    6              0.000006     if empty(fileinfo)
                                    return {}
    6              0.000002     endif
                            
    6              0.000007     let typeinfo = fileinfo.typeinfo
    6              0.000004     if a:0 > 0
                                    let curline = a:1
    6              0.000002     else
    6              0.000009         let curline = line('.')
    6              0.000002     endif
    6              0.000005     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  135              0.000090     for line in range(curline, 1, -1)
  130              0.000174         if has_key(fileinfo.fline, line)
    1              0.000002             let curtag = fileinfo.fline[line]
    1   0.000014   0.000007             if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
    1              0.000001                 let tag = curtag
    1              0.000001                 break
                                        elseif a:request ==# 'scoped-stl' && typeinfo.getKind(curtag.fields.kind).stl && curtag.fields.line <= curline && curline <= curtag.fields.end
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'nearest' || line == curline
                                            let tag = curtag
                                            break
                                        endif
  129              0.000041         endif
  135              0.000053     endfor
                            
    6              0.000004     return tag

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 102
Called 10 times
Total time:   0.000273
 Self time:   0.000090

count  total (s)   self (s)
   10   0.000268   0.000085   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>103_GetVars()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 49
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000058   call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')

FUNCTION  coc#float#get_config_cursor()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 833
Called 4 times
Total time:   0.000868
 Self time:   0.000531

count  total (s)   self (s)
    4              0.000009   let preferTop = get(a:config, 'preferTop', 0)
    4              0.000012   let title = get(a:config, 'title', '')
    4              0.000010   let border = get(a:config, 'border', [0, 0, 0, 0])
    4   0.000053   0.000027   if s:empty_border(border) && len(title)
                                let border = [1, 1, 1, 1]
    4              0.000002   endif
    4              0.000009   let bh = get(border, 0, 0) + get(border, 2, 0)
    4              0.000011   let vh = &lines - &cmdheight - 1
    4              0.000003   if vh <= 0
                                return v:null
    4              0.000001   endif
    4   0.000080   0.000025   let maxWidth = coc#helper#min(get(a:config, 'maxWidth', 80), &columns - 1)
    4              0.000003   if maxWidth < 3
                                return v:null
    4              0.000001   endif
    4   0.000064   0.000022   let maxHeight = coc#helper#min(get(a:config, 'maxHeight', 80), vh)
    4              0.000003   let ch = 0
    4   0.000064   0.000021   let width = coc#helper#min(40, strdisplaywidth(title)) + 3
   21              0.000016   for line in a:lines
   17              0.000046     let dw = max([1, strdisplaywidth(line)])
   17              0.000029     let width = max([width, dw + 2])
   17              0.000072     let ch += float2nr(ceil(str2float(string(dw))/(maxWidth - 2)))
   21              0.000009   endfor
    4   0.000060   0.000017   let width = coc#helper#min(maxWidth, width)
    4   0.000048   0.000019   let [lineIdx, colIdx] = coc#util#cursor_pos()
                              " How much we should move left
    4   0.000062   0.000021   let offsetX = coc#helper#min(get(a:config, 'offsetX', 0), colIdx)
    4              0.000007   let showTop = 0
    4              0.000005   let hb = vh - lineIdx -1
    4              0.000009   if lineIdx > bh + 2 && (preferTop || (lineIdx > hb && hb < ch + bh))
                                let showTop = 1
    4              0.000001   endif
    4   0.000079   0.000022   let height = coc#helper#min(maxHeight, ch + bh, showTop ? lineIdx - 1 : hb)
    4              0.000003   if height <= bh
                                return v:null
    4              0.000001   endif
    4              0.000012   let col = - max([offsetX, colIdx - (&columns - 1 - width)])
    4              0.000005   let row = showTop ? - height + bh : 1
    4              0.000014   return { 'row': row, 'col': col, 'width': width - 2, 'height': height - bh }

FUNCTION  <SNR>77_TagbarBufName()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3574
Called 14 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   14              0.000027     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
   14              0.000004     endif
                            
   14              0.000013     return t:tagbar_buf_name

FUNCTION  12()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 244
Called 230 times
Total time:   0.000843
 Self time:   0.000843

count  total (s)   self (s)
  230              0.000248     if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
  230              0.000058     endif
                            
  230              0.000154     return self.cachedDisplayString

FUNCTION  19()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 331
Called 19080 times
Total time:   0.127054
 Self time:   0.127054

count  total (s)   self (s)
19080              0.022238     if empty(self.pathSegments)
                                    return ''
19080              0.004825     endif
19080              0.024819     let toReturn = self.pathSegments[-1]
19080              0.016618     if a:dirSlash && self.isDirectory
 5890              0.007827         let toReturn = toReturn . '/'
19080              0.004885     endif
19080              0.012646     return toReturn

FUNCTION  <SNR>77_get_map_str()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2177
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003     let def = get(g:, 'tagbar_map_' . a:map)
    1              0.000002     if type(def) ==# type('')
                                    return def
    1              0.000000     else
    1              0.000002         return join(def, ', ')
                                endif

FUNCTION  24()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 432
Called 6465 times
Total time:   0.063191
 Self time:   0.025235

count  total (s)   self (s)
 6465   0.061656   0.023700     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 453
Called 6465 times
Total time:   0.447072
 Self time:   0.203855

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 6465   0.022741   0.016598     if a:nerdtree.ui.isIgnoreFilterEnabled()
12930              0.010875         for i in g:NERDTreeIgnore
 6465   0.158730   0.018749             if self._ignorePatternMatches(i)
                                            return 1
 6465              0.002063             endif
12930              0.005398         endfor
                            
 6465   0.041647   0.019164         for Callback in g:NERDTree.PathFilters()
                                        let Callback = type(Callback) ==# type(function('tr')) ? Callback : function(Callback)
                                        if Callback({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
 6465              0.003290         endfor
 6465              0.001964     endif
                            
                                "dont show hidden files unless instructed to
 6465   0.098971   0.030087     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   15              0.000007         return 1
 6450              0.001534     endif
                            
 6450   0.025248   0.019521     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
 6450              0.001508     endif
                            
 6450              0.002691     return 0

FUNCTION  coc#_do_complete()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 68
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000013   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    1              0.000006   if mode() =~# 'i' && &paste != 1
                                call feedkeys("\<Plug>CocRefresh", 'i')
    1              0.000001   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 164
Called 4 times
Total time:   0.001481
 Self time:   0.000117

count  total (s)   self (s)
    4   0.000678   0.000071   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    4   0.000786   0.000029   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>134_syn_name()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\comment.vim line 32
Called 116 times
Total time:   0.005377
 Self time:   0.005377

count  total (s)   self (s)
  116              0.004927   let syn_id = get(synstack(a:lnum, a:cnum), -1)
  116              0.000328   return synIDattr(syn_id, "name")

FUNCTION  <SNR>56_abs_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 205
Called 32 times
Total time:   0.004526
 Self time:   0.004526

count  total (s)   self (s)
   32              0.003838   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   32              0.000537   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   32              0.000079   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  111()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 88
Called 155 times
Total time:   0.003426
 Self time:   0.000865

count  total (s)   self (s)
  155   0.003390   0.000829     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  112()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 102
Called 105 times
Total time:   0.013802
 Self time:   0.000620

count  total (s)   self (s)
  105   0.013779   0.000597     return self.path.str() ==# a:treenode.path.str()

FUNCTION  115()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 157
Called 12720 times
Total time:   0.012317
 Self time:   0.012317

count  total (s)   self (s)
12720              0.009227     return self._nerdtree

FUNCTION  <SNR>130_process_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 293
Called 7 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    7              0.000006   let offset = 0
   34              0.000029   while offset < a:to_count
   27              0.000031     let line_number = a:to_line + offset
   27              0.000051     call add(a:modifications, [line_number, 'added'])
   27              0.000021     let offset += 1
   34              0.000014   endwhile

FUNCTION  302()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 70
Called 7 times
Total time:   0.020802
 Self time:   0.020802

count  total (s)   self (s)
    7              0.020647         let jid = jobstart(a:cmd, { 'on_stdout': {_job_id, data, _event  -> self.onStdoutCB(data)}, 'on_stderr': {_job_id, data, _event  -> self.onStderrCB(data)}, 'on_exit':   {_job_id, _data, _event -> self.onExitCB()}, 'env':       {'GIT_OPTIONAL_LOCKS': '0'}, })
    7              0.000051         let self.id = jid
    7              0.000013         let self.running = jid > 0
    7              0.000008         if jid <= 0
                                        let self.failed = 1
                                        let self.err_chunks = jid == 0 ? ['invalid arguments'] : ['command is not executable']
                                        call self.onExitCB()
    7              0.000005         endif

FUNCTION  <SNR>130_save_last_seen_change()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 415
Called 4 times
Total time:   0.000095
 Self time:   0.000037

count  total (s)   self (s)
    4   0.000093   0.000035   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  36()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 645
Called 6150 times
Total time:   3.647458
 Self time:   0.049848

count  total (s)   self (s)
 6150   3.388730   0.031000     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
 6150   0.256057   0.016177     call self.cacheDisplayString()

FUNCTION  38()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 695
Called 12527 times
Total time:   0.820311
 Self time:   0.421435

count  total (s)   self (s)
12527              0.019372     let options = a:0 ? a:1 : {}
12527              0.010275     let toReturn = ''
                            
12527              0.017190     if has_key(options, 'format')
    5              0.000006         let format = options['format']
    5              0.000009         if has_key(self, '_strFor' . format)
    5   0.000071   0.000025             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
    5              0.000002         endif
12522              0.003950     else
12522   0.409118   0.041151         let toReturn = self._str()
12527              0.004146     endif
                            
12527   0.080814   0.049951     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
12527              0.003783     endif
                            
12527              0.015172     if has_key(options, 'truncateTo')
    5              0.000006         let limit = options['truncateTo']
    5              0.000012         if strdisplaywidth(toReturn) > limit-1
  140              0.000354             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  135              0.000365                 let toReturn = substitute(toReturn, '^.', '', '')
  140              0.000043             endwhile
    5              0.000023             if len(split(toReturn, '/')) > 1
    5              0.000027                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    5              0.000002             endif
    5              0.000002         endif
12527              0.003352     endif
                            
12527              0.009326     return toReturn

FUNCTION  39()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 732
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    5              0.000022     let toReturn = '/' . join(self.pathSegments, '/')
    5              0.000008     if self.isDirectory && toReturn !=# '/'
    5              0.000006         let toReturn  = toReturn . '/'
    5              0.000001     endif
    5              0.000004     return toReturn

FUNCTION  <SNR>103_Token()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 169
Called 2 times
Total time:   0.000030
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000029   0.000020   return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()

FUNCTION  <SNR>51_onCursorHold()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 187
Called 5 times
Total time:   0.013845
 Self time:   0.000210

count  total (s)   self (s)
                                " Do not update when a special buffer is selected
    5              0.000013     if !empty(&l:buftype)
                                    return
    5              0.000002     endif
    5              0.000033     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
                            
    5   0.000059   0.000034     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    5              0.000001     endif
                            
    5   0.013339   0.000031     let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
    5   0.000378   0.000075     call s:logger.debug('run cursor-hold job: ' . l:job.id)

FUNCTION  <SNR>22_SyncAutocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 235
Called 2 times
Total time:   0.026338
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000005   if !g:coc_workspace_initialized
                                return
    2              0.000001   endif
    2              0.000002   if g:coc_service_initialized
    2   0.026318   0.000015     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    2              0.000001   endif

FUNCTION  coc#util#get_complete_option()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 329
Called 1 time
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
    1              0.000007   let pos = getcurpos()
    1              0.000003   let line = getline(pos[1])
    1              0.000012   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
    1              0.000003   let col = pos[2] - strlen(input)
    1              0.000048   let synname = synIDattr(synID(pos[1], col, 1), 'name')
    1              0.000188   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  128()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 288
Called 260 times
Total time:   0.150625
 Self time:   0.001329

count  total (s)   self (s)
  260   0.150553   0.001257     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  <SNR>90_empty_border()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 925
Called 13 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   13              0.000016   if empty(a:border)
    9              0.000005     return 1
    4              0.000001   endif
    4              0.000010   if a:border[0] == 0 && a:border[1] == 0 && a:border[2] == 0 && a:border[3] == 0
    4              0.000002     return 1
                              endif
                              return 0

FUNCTION  <SNR>56_exists_file()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 223
Called 10 times
Total time:   0.002450
 Self time:   0.000680

count  total (s)   self (s)
   10   0.002444   0.000673   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>103_Nat()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 161
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002   return a:int * (a:int > 0)

FUNCTION  <SNR>135_is_jsx_backticks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 96
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   return a:syntax =~? 'jsxBackticks'

FUNCTION  43()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 790
Called 12522 times
Total time:   0.367966
 Self time:   0.199516

count  total (s)   self (s)
12522   0.180554   0.047551     let l:separator = nerdtree#slash()
12522              0.014194     let l:leader = l:separator
                            
12522   0.080911   0.045465     if nerdtree#runningWindows()
12522              0.020317         let l:leader = self.drive . l:separator
12522              0.004398     endif
                            
12522              0.051094     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  coc#float#create_cursor_float()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 454
Called 4 times
Total time:   0.229763
 Self time:   0.223894

count  total (s)   self (s)
    4              0.000022   if !s:float_supported
                                return v:null
    4              0.000003   endif
    4   0.000072   0.000032   if s:is_blocking()
                                return v:null
    4              0.000001   endif
    4              0.000017   let pumAlignTop = get(a:config, 'pumAlignTop', 0)
    4              0.000014   let modes = get(a:config, 'modes', ['n', 'i', 'ic', 's'])
    4              0.000005   let mode = mode()
    4              0.000009   let currbuf = bufnr('%')
    4              0.000010   let pos = [line('.'), col('.')]
    4              0.000008   if index(modes, mode) == -1
                                return v:null
    4              0.000001   endif
    4              0.000011   if has('nvim') && mode ==# 'i'
                                " helps to fix undo issue, don't know why.
                                call feedkeys("\<C-g>u", 'n')
    4              0.000001   endif
    4   0.000900   0.000032   let dimension = coc#float#get_config_cursor(a:lines, a:config)
    4              0.000004   if empty(dimension)
                                return v:null
    4              0.000001   endif
    4              0.000010   if pumvisible() && ((pumAlignTop && dimension['row'] <0)|| (!pumAlignTop && dimension['row'] > 0))
                                return v:null
    4              0.000001   endif
    4              0.000005   let width = dimension['width']
    4   0.000150   0.000080   let lines = map(a:lines, {_, s -> s =~# '^—' ? repeat('—', width) : s})
    4              0.000078   let config = extend({'lines': lines, 'relative': 'cursor'}, a:config)
    4              0.000052   let config = extend(config, dimension)
    4   0.000383   0.000023   call coc#float#close_auto_hide_wins(a:winid)
    4   0.003142   0.000031   let res = coc#float#create_float_win(a:winid, a:bufnr, config)
    4              0.000004   if empty(res)
                                return v:null
    4              0.000001   endif
    4              0.000005   let winid = res[0]
    4              0.000004   let bufnr = res[1]
    4   0.000876   0.000034   call coc#highlight#add_highlights(winid, get(a:config, 'codes', []), get(a:config, 'highlights', []))
    4              0.223264   redraw
    4              0.000016   if has('nvim')
    4   0.000618   0.000040     call coc#float#nvim_scrollbar(winid)
    4              0.000001   endif
    4              0.000009   return [currbuf, pos, winid, bufnr]

FUNCTION  <SNR>77_ProcessFile()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1184
Called 1 time
Total time:   0.048823
 Self time:   0.001408

count  total (s)   self (s)
    1   0.000008   0.000005     call tagbar#debug#log('ProcessFile called [' . a:fname . ']')
                            
    1   0.000222   0.000005     if !s:IsValidFile(a:fname, a:ftype)
                                    call tagbar#debug#log('Not a valid file, returning')
                                    return
    1              0.000000     endif
                            
    1              0.000036     let l:bufnum = bufnr(a:fname)
                            
    1              0.000002     if !bufloaded(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer is not loaded exiting...')
                                    return
    1              0.000000     endif
    1              0.000001     if !bufexists(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer does not exist exiting...')
                                    return
    1              0.000000     endif
                            
    1              0.000002     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
    1   0.000019   0.000012     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
    1   0.000005   0.000003         let fileinfo = s:known_files.get(a:fname)
    1              0.000001         let typeinfo = fileinfo.typeinfo
    1   0.000110   0.000005         call fileinfo.reset()
                                else
                                    if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
                                    let fileinfo = tagbar#prototypes#fileinfo#new(a:fname, a:ftype, typeinfo)
    1              0.000000     endif
                            
    1   0.000027   0.000022     call tagbar#debug#log('typeinfo for file to process: ' . string(typeinfo))
                            
    1              0.000003     if g:tagbar_file_size_limit > 0 && fileinfo.fsize > g:tagbar_file_size_limit && !exists('b:tagbar_force_update')
                                    call tagbar#debug#log('File size exceeds defined limit')
                                    let fileinfo.fsize_exceeded = 1
                                    call s:known_files.put(fileinfo)
                                    return
    1              0.000001     elseif g:tagbar_use_cache
                                    " Use a temporary files for ctags processing instead of the original one.
                                    " This allows using Tagbar for files accessed with netrw, and also doesn't
                                    " slow down Tagbar for files that sit on slow network drives.
    1              0.000003         let tempfile = tempname()
    1              0.000003         let ext = fnamemodify(fileinfo.fpath, ':e')
    1              0.000001         if ext !=# ''
    1              0.000002             let tempfile .= '.' . ext
    1              0.000000         endif
                            
    1   0.000008   0.000004         call tagbar#debug#log('Caching file into: ' . tempfile)
    1              0.000031         let templines = getbufline(fileinfo.bufnr, 1, '$')
    1              0.000472         let res = writefile(templines, tempfile)
                            
    1              0.000003         if res != 0
                                        call tagbar#debug#log('Could not create copy '.tempfile)
                                        return
    1              0.000000         endif
    1              0.000048         let fileinfo.mtime = getftime(tempfile)
    1              0.000002         let fileinfo.fsize_exceeded = 0
                            
    1   0.044152   0.000017         let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
    1   0.000005   0.000004         if !tagbar#debug#enabled()
    1              0.000201             call delete(tempfile)
    1              0.000001         endif
                                else
                                    call tagbar#debug#log('File caching disabled')
                                    let fileinfo.fsize_exceeded = 0
                                    let ctags_output = s:ExecuteCtagsOnFile(a:fname, a:fname, typeinfo)
    1              0.000001     endif
                            
    1              0.000002     if ctags_output == -1
                                    call tagbar#debug#log('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
    1              0.000001     elseif ctags_output ==# ''
                                    call tagbar#debug#log('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(tagbar#prototypes#fileinfo#new(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
    1              0.000000     endif
                            
    1   0.000022   0.000017     call tagbar#debug#log('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
    1   0.000010   0.000006     call tagbar#debug#log('Parsing ctags output')
    1              0.000009     let rawtaglist = split(ctags_output, '\n\+')
    1              0.000002     let seen = {}
    3              0.000007     for line in rawtaglist
                                    " skip comments and duplicates (can happen when --sort=no)
    2              0.000015         if line =~# '^!_TAG_' || has_key(seen, line)
                                        continue
    2              0.000001         endif
    2              0.000005         if g:tagbar_ignore_anonymous && line =~# '__anon'
                                        call tagbar#debug#log('anonymous tag found - ignoring per tagbar configuration')
                                        continue
    2              0.000001         endif
                            
    2              0.000007         let seen[line] = 1
                            
    2              0.000012         let parts = split(line, ';"')
    2              0.000005         if len(parts) == 2 " Is a valid tag line
    2   0.002740   0.000039             call s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
    2              0.000001         endif
    3              0.000004     endfor
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes, but
                                " only for non-scoped tags
    9              0.000015     for kind in typeinfo.kinds
    8              0.000045         if has_key(get(typeinfo, 'kind2scope', {}), kind.short)
    5              0.000005             continue
    3              0.000002         endif
                            
    3   0.000087   0.000079         let curtags = filter(copy(fileinfo.getTags()), 'v:val.fields.kind ==# kind.short && ' . '!has_key(v:val, "scope")')
    3   0.000074   0.000044         call tagbar#debug#log('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
    3              0.000007         if empty(curtags)
    3              0.000003             continue
                                    endif
                            
                                    let kindtag          = tagbar#prototypes#kindheadertag#new(kind.long)
                                    let kindtag.short    = kind.short
                                    let kindtag.numtags  = len(curtags)
                                    let kindtag.fileinfo = fileinfo
                            
                                    for tag in curtags
                                        let tag.parent = kindtag
                                    endfor
    1              0.000003     endfor
                            
                                " Clear old folding information from previous file version to prevent leaks
    1   0.000024   0.000013     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
    1   0.000177   0.000012     call fileinfo.sortTags(typeinfo)
                            
    1   0.000017   0.000008     call s:known_files.put(fileinfo)

FUNCTION  130()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 310
Called 5 times
Total time:   0.539497
 Self time:   0.000033

count  total (s)   self (s)
    5   0.539495   0.000031     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 319
Called 235 times
Total time:   1.152906
 Self time:   0.677435

count  total (s)   self (s)
  235              0.000176     let output = ''
  235              0.000151     if a:drawText ==# 1
                            
  230              0.000402         let treeParts = repeat('  ', a:depth - 1)
  230              0.000573         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
  230   0.494201   0.000817         let line = treeParts . self.displayString()
  230              0.000360         let output = output . line . "\n"
  235              0.000069     endif
                            
                                " if the node is an open dir, draw its children
  235              0.000240     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   30   0.018935   0.000107         let childNodesToDraw = self.getVisibleChildren()
                            
   30   0.020320   0.000099         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
   30              0.000040         elseif len(childNodesToDraw) > 0
  260              0.000155             for i in childNodesToDraw
  230              0.000638                 let output = output . i._renderToString(a:depth + 1, 1)
  260              0.000090             endfor
   30              0.000010         endif
  235              0.000056     endif
                            
  235              0.000156     return output

FUNCTION  138()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_dir_node.vim line 95
Called 75 times
Total time:   0.489958
 Self time:   0.002175

count  total (s)   self (s)
   75              0.000066     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   75              0.000054     let l:label = ''
   75   0.486602   0.000232     let l:cascade = self.getCascade()
  150              0.000133     for l:dirNode in l:cascade
   75   0.000549   0.000254         let l:next = l:dirNode.path.displayString()
   75              0.000220         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  150              0.000059     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   75              0.000202     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
   75              0.000143     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
   75   0.001392   0.000274     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   75              0.000117     return l:symbol . l:flags . l:label

FUNCTION  gitgutter#diff#parse_diff()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 205
Called 4 times
Total time:   0.002569
 Self time:   0.001007

count  total (s)   self (s)
    4              0.000007   let hunks = []
  105              0.000134   for line in split(a:diff, '\n')
  101   0.002092   0.000529     let hunk_info = gitgutter#diff#parse_hunk(line)
  101              0.000109     if len(hunk_info) == 4
   24              0.000036       call add(hunks, hunk_info)
  101              0.000032     endif
  105              0.000039   endfor
    4              0.000003   return hunks

FUNCTION  140()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_dir_node.vim line 141
Called 75 times
Total time:   0.486370
 Self time:   0.001147

count  total (s)   self (s)
   75   0.486260   0.001038     if !self.isCascadable()
   75              0.000064         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  gitgutter#diff#process_hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 231
Called 4 times
Total time:   0.002732
 Self time:   0.000201

count  total (s)   self (s)
    4              0.000005   let modified_lines = []
   28              0.000021   for hunk in a:hunks
   24   0.002677   0.000146     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   28              0.000012   endfor
    4              0.000003   return modified_lines

FUNCTION  <SNR>56_winshell()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 68
Called 14 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   14              0.000094   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>135_trim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 20
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000019   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>21_CursorHoldUpdate()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-devicons\plugin\webdevicons.vim line 397
Called 5 times
Total time:   4.270384
 Self time:   0.000286

count  total (s)   self (s)
    5              0.000027   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    5              0.000003   endif
                            
    5   0.000463   0.000042   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
    5              0.000002   endif
                            
                              " Do not update when a special buffer is selected
    5              0.000017   if !empty(&l:buftype)
                                return
    5              0.000001   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
    5              0.000013   let l:winnr = winnr()
    5              0.000008   let l:altwinnr = winnr('#')
                            
    5   0.000771   0.000021   call g:NERDTree.CursorToTreeWin()
    5   3.726982   0.000029   call b:NERDTree.root.refreshFlags()
    5   0.541994   0.000020   call NERDTreeRender()
                            
    5              0.000019   exec l:altwinnr . 'wincmd w'
    5              0.000031   exec l:winnr . 'wincmd w'

FUNCTION  coc#prompt#activated()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\prompt.vim line 180
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000006   return s:activated

FUNCTION  coc#helper#dict_pick()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\helper.vim line 59
Called 4 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
    4              0.000004   let res = {}
   72              0.000060   for key in keys(a:dict)
   68              0.000095     if index(a:keys, key) != -1
   20              0.000035       let res[key] = a:dict[key]
   68              0.000022     endif
   72              0.000025   endfor
    4              0.000003   return res

FUNCTION  150()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_dir_node.vim line 358
Called 130 times
Total time:   0.506779
 Self time:   0.053851

count  total (s)   self (s)
  130              0.000120     let toReturn = []
 6595              0.004356     for i in self.children
 6465   0.487734   0.034805         if i.path.ignore(self.getNerdtree()) ==# 0
 6450              0.008592             call add(toReturn, i)
 6465              0.002071         endif
 6595              0.002176     endfor
  130              0.000073     return toReturn

FUNCTION  152()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_dir_node.vim line 382
Called 105 times
Total time:   0.505444
 Self time:   0.002043

count  total (s)   self (s)
  105              0.000138     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
  105              0.000027     endif
                            
  105   0.015349   0.000280     if self.isRoot()
    5              0.000002         return 0
  100              0.000025     endif
                            
  100              0.000072     if self.path.isSymLink
                                    return 0
  100              0.000023     endif
                            
  100   0.000741   0.000361     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
  100              0.000054     endfor
                            
  100   0.488257   0.000305     let c = self.getVisibleChildren()
  100              0.000171     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  <SNR>135_is_opening_tag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 56
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  tagbar#state#get_current_file()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\state.vim line 1
Called 39 times
Total time:   0.000735
 Self time:   0.000279

count  total (s)   self (s)
   39   0.000723   0.000267     return s:get().getCurrent(a:force_current)

FUNCTION  gitstatus#getIndicator()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus.vim line 61
Called 55 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
   55              0.000217     return get(get(g:, 'NERDTreeGitStatusIndicatorMapCustom', {}), a:status, s:indicatorMap[a:status])

FUNCTION  NERDTreeRender()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\plugin\NERD_tree.vim line 187
Called 5 times
Total time:   0.541974
 Self time:   0.000024

count  total (s)   self (s)
    5   0.541971   0.000021     call nerdtree#renderView()

FUNCTION  162()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_dir_node.vim line 599
Called 5890 times
Total time:  11.165038
 Self time:   7.276062

count  total (s)   self (s)
 5890   3.534864   0.030355     call self.path.refreshFlags(self.getNerdtree())
12035              0.012261     for i in self.children
 6145   0.162534   0.011909         call i.refreshFlags()
12035              0.005091     endfor

FUNCTION  <SNR>56_unc_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 169
Called 4 times
Total time:   0.000582
 Self time:   0.000050

count  total (s)   self (s)
    4   0.000579   0.000047   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-devicons\plugin\webdevicons.vim line 602
Called 6150 times
Total time:   1.772124
 Self time:   0.469934

count  total (s)   self (s)
 6150              0.006980   let path = a:event.subject
 6150              0.010209   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
 6150              0.009724   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
 6150   0.055141   0.027480   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
 6150              0.016267   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
 6150   0.063923   0.031387   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
 6150              0.012271   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
 6095              0.007990     let prePadding .= ' '
 6150              0.001800   endif
                            
 6150              0.004446   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
  260   0.049788   0.002198     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
 5890              0.008492   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
 5890              0.006153     let directoryOpened = 0
                            
 5890              0.013622     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
 5890              0.001777     endif
                            
 5890              0.007147     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
 5890              0.006529       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
 5890              0.002089       else
                                    " the folder is not open
 5890              0.003992         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
 5890              0.001983         else
                                      " We have a regular folder
 5890   1.161672   0.055836           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
 5890              0.002106         endif
 5890              0.001645       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
 5890              0.001745     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
 6150              0.001731   endif
                            
 6150   0.035857   0.020440   call path.flagSet.clearFlags('webdevicons')
                            
 6150              0.005480   if flag !=? ''
 6150   0.093220   0.020070     call path.flagSet.addFlag('webdevicons', flag)
 6150              0.001811   endif
                            

FUNCTION  81()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\bookmark.vim line 35
Called 6250 times
Total time:   0.024419
 Self time:   0.024419

count  total (s)   self (s)
 6250              0.010870     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
 6250              0.001629     endif
 6250              0.004664     return g:NERDTreeBookmarks

FUNCTION  <SNR>103_sw()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 55
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return shiftwidth()

FUNCTION  gitgutter#debug#log()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\debug.vim line 70
Called 8 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
    8              0.000009   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    8              0.000004   endif

FUNCTION  <SNR>84_setup_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 156
Called 10 times
Total time:   0.000340
 Self time:   0.000067

count  total (s)   self (s)
   10   0.000328   0.000056   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>77_HandleBufWrite()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3515
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000014     if index(s:delayed_update_files, a:fname) == -1
    1              0.000019         call add(s:delayed_update_files, a:fname)
    2              0.000001     endif

FUNCTION  coc#highlight#ranges()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 15
Called 4 times
Total time:   0.000441
 Self time:   0.000332

count  total (s)   self (s)
    4              0.000009   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    4              0.000009   if !bufloaded(bufnr) || !exists('*getbufline')
                                return
    4              0.000001   endif
    4   0.000049   0.000021   let srcId = s:create_namespace(a:key)
    9              0.000009   for range in a:ranges
    5              0.000006     let start = range['start']
    5              0.000006     let end = range['end']
   10              0.000016     for lnum in range(start['line'] + 1, end['line'] + 1)
    5              0.000011       let arr = getbufline(bufnr, lnum)
    5              0.000010       let line = empty(arr) ? '' : arr[0]
    5              0.000005       if empty(line)
                                    continue
    5              0.000002       endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
    5              0.000019       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
    5              0.000018       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
    5              0.000004       if colStart == colEnd
                                    continue
    5              0.000002       endif
    5   0.000113   0.000032       call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
   10              0.000005     endfor
    9              0.000005   endfor

FUNCTION  gitstatus#job#Spawn()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 132
Called 7 times
Total time:   0.021062
 Self time:   0.000100

count  total (s)   self (s)
    7   0.000201   0.000040     let l:job = s:newJob(a:name, a:opts)
    7   0.020843   0.000042     call l:job.run(a:cmd)
    7              0.000012     return l:job

FUNCTION  <SNR>58_build_command()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 43
Called 4 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    4              0.000013   if has('unix')
                                return ['sh', '-c', a:cmd]
    4              0.000002   endif
                            
    4              0.000004   if has('win32')
    4              0.000014     return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#hunk#hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 10
Called 4 times
Total time:   0.000051
 Self time:   0.000022

count  total (s)   self (s)
    4   0.000049   0.000020   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitstatus#util#ParseGitStatusLine()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 174
Called 42 times
Total time:   0.001620
 Self time:   0.001136

count  total (s)   self (s)
   42              0.000096     if get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2
   42              0.000061         if a:statusLine[0] ==# '1'
   35   0.000722   0.000238             let l:statusKey = s:getStatusKey(a:statusLine[2], a:statusLine[3])
   35              0.000072             let l:pathStr = a:statusLine[113:]
    7              0.000008         elseif a:statusLine[0] ==# '2'
                                        let l:statusKey = 'Renamed'
                                        let l:pathStr = a:statusLine[113:]
                                        let l:pathStr = l:pathStr[stridx(l:pathStr, ' ')+1:]
    7              0.000008         elseif a:statusLine[0] ==# 'u'
                                        let l:statusKey = 'Unmerged'
                                        let l:pathStr = a:statusLine[161:]
    7              0.000007         elseif a:statusLine[0] ==# '?'
    7              0.000007             let l:statusKey = 'Untracked'
    7              0.000010             let l:pathStr = a:statusLine[2:]
                                    elseif a:statusLine[0] ==# '!'
                                        let l:statusKey = 'Ignored'
                                        let l:pathStr = a:statusLine[2:]
                                    else
                                        throw '[nerdtree_git_status] unknown status: ' . a:statusLine
   42              0.000015         endif
   42              0.000068         return [l:pathStr, l:statusKey]
                                else
                                    let l:pathStr = a:statusLine[3:]
                                    let l:statusKey = s:getStatusKey(a:statusLine[0], a:statusLine[1])
                                    return [l:pathStr, l:statusKey]
                                endif

FUNCTION  coc#_cancel()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 102
Called 5 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                              " hack for close pum
    5              0.000010   if pumvisible()
                                let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
                                call feedkeys("\<Plug>CocRefresh", 'i')
                                call coc#rpc#notify('stopCompletion', [])
    5              0.000003   endif

FUNCTION  <SNR>130_is_removed()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 277
Called 17 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
   17              0.000021   return a:from_count > 0 && a:to_count == 0

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 34
Called 17 times
Total time:   0.000564
 Self time:   0.000190

count  total (s)   self (s)
   17   0.000289   0.000073   let summary = gitgutter#hunk#summary(a:bufnr)
   17              0.000021   let summary[1] += a:count
   17   0.000245   0.000087   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>51_onGitStatusSuccessCB()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 160
Called 7 times
Total time:   0.005397
 Self time:   0.000293

count  total (s)   self (s)
    7              0.000032     if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
                                    call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
                                    return
    7              0.000003     endif
    7              0.000039     let l:output = join(a:job.chunks, '')
    7              0.000059     let l:lines = split(l:output, "\n")
    7   0.004470   0.000058     let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
                            
    7   0.000064   0.000032     call s:listener.SetNext(l:cache)
    7   0.000683   0.000022     call s:listener.TryUpdateNERDTreeUI()

FUNCTION  27()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\path.vim line 484
Called 6465 times
Total time:   0.139981
 Self time:   0.099605

count  total (s)   self (s)
 6465              0.006211     let pat = a:pattern
 6465              0.012610     if strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
 6465              0.011597     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
 6465              0.001613     endif
                            
 6465   0.066557   0.026181     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>123_addTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 69
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000010     call add(self._taglist, a:tag)
                            
    2              0.000007     if has_key(self._tagdict, a:tag.name)
                                    call add(self._tagdict[a:tag.name], a:tag)
    2              0.000001     else
    2              0.000008         let self._tagdict[a:tag.name] = [a:tag]
    2              0.000001     endif

FUNCTION  <SNR>58_on_exit_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 72
Called 4 times
Total time:   0.007152
 Self time:   0.000145

count  total (s)   self (s)
    4              0.000017   if !a:exit_code
    4   0.007127   0.000120     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    4              0.000002   endif

FUNCTION  <SNR>77_PrintHelp()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2122
Called 1 time
Total time:   0.000064
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000003     if !g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
    1   0.000025   0.000016         silent 0put ='\" Press ' . s:get_map_str('help') . ' for help'
    1              0.000004         silent  put _
                                elseif g:tagbar_help_visibility || !s:short_help
                                    let help_cmds = [ ['jump',              'Jump to tag definition'], ['preview',           'As above, but stay in tagbar window'], ['previewwin',        'Show tag in preview window'], ['nexttag',           'Go to next top-level tag'], ['prevtag',           'Go to previous top-level tag'], ['showproto',         'Display tag prototype'], ['hidenonpublic',     'Hide non-public tags'], ]
                                    let fold_cmds = [ ['openfold',          'Open fold'], ['closefold',         'Close fold'], ['togglefold',        'Toggle fold'], ['openallfolds',      'Open all folds'], ['closeallfolds',     'Close all folds'], ['incrementfolds',    'Increment fold level by 1'], ['decrementfolds',    'Decrement fold level by 1'], ['nextfold',          'Go to next fold'], ['prevfold',          'Go to previous fold'], ]
                                    let misc_cmds = [ ['togglesort',        'Toggle sort'], ['togglecaseinsensitive', 'Toggle case insensitive sort option'], ['toggleautoclose',   'Toggle autoclose option'], ['togglepause',       'Toggle pause'], ['zoomwin',           'Zoom window in/out'], ['close',             'Close window'], ['help',              'Toggle help'], ]
                            
                                    silent 0put ='\" Tagbar keybindings'
                                    silent  put ='\"'
                                    silent  put ='\" --------- General ---------'
                                    for [cmd, desc] in help_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Folds ----------'
                                    for [cmd, desc] in fold_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Misc -----------'
                                    for [cmd, desc] in misc_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put _
    1              0.000000     endif

FUNCTION  <SNR>77_ParseTagline()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1457
Called 2 times
Total time:   0.002701
 Self time:   0.000403

count  total (s)   self (s)
    2              0.000016     let basic_info  = split(a:part1, '\t')
    2              0.000005     let tagname  = basic_info[0]
    2              0.000004     let filename = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
    2              0.000011     let pattern = join(basic_info[2:], "\t")
    2              0.000004     if pattern[0] ==# '/'
    2              0.000002         let start   = 2 " skip the slash and the ^
    2              0.000005         let end     = strlen(pattern) - 1
    2              0.000004         if pattern[end - 1] ==# '$'
    2              0.000003             let end -= 1
    2              0.000003             let dollar = '\$'
                                    else
                                        let dollar = ''
    2              0.000001         endif
    2              0.000009         let pattern = '\V\^\C' . strpart(pattern, start, end - start) . dollar
                                else
                                    let pattern = ''
    2              0.000001     endif
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
    2              0.000033     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
    2              0.000004     let fielddict = {}
    2              0.000007     if fields[0] !~# ':'
    2              0.000006         let fielddict.kind = remove(fields, 0)
    2              0.000001     endif
    6              0.000008     for field in fields
                                    " can't use split() since the value can contain ':'
    4              0.000010         let delimit = stridx(field, ':')
    4              0.000010         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
    4              0.000023         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
    4              0.000005         if key ==# 'file'
                                        let fielddict[key] = 'yes'
    4              0.000002         endif
    4              0.000009         if len(val) > 0
    4              0.000009             if key ==# 'line' || key ==# 'column' || key ==# 'end'
    2              0.000006                 let fielddict[key] = str2nr(val)
    2              0.000001             else
    2              0.000004                 let fielddict[key] = val
    4              0.000002             endif
    4              0.000002         endif
    6              0.000005     endfor
                            
                                " If the tag covers multiple scopes, split it up and create individual tags
                                " for each scope so that the hierarchy can be displayed correctly.
                                " This can happen with PHP's 'namespace' tags in uctags, for example.
    2              0.000019     if has_key(a:typeinfo, 'kind2scope') && has_key(a:typeinfo.kind2scope, fielddict.kind) && tagname =~# '\V' . escape(a:typeinfo.sro, '\')
                                    let tagparts = split(tagname, '\V' . escape(a:typeinfo.sro, '\'))
                            
                                    let scope = a:typeinfo.kind2scope[fielddict.kind]
                                    if has_key(fielddict, scope)
                                        let parent = fielddict[scope]
                                    else
                                        let parent = ''
                                    endif
                                    let curfielddict = fielddict
                            
                                    for i in range(len(tagparts))
                                        let part = tagparts[i]
                                        call s:ProcessTag(part, filename, pattern, curfielddict, i != len(tagparts) - 1, a:typeinfo, a:fileinfo)
                                        if parent !=# ''
                                            let parent = parent . a:typeinfo.sro . part
                                        else
                                            let parent = part
                                        endif
                                        let curfielddict = copy(fielddict)
                                        let curfielddict[scope] = parent
                                    endfor
    2              0.000001     else
    2   0.002325   0.000027         call s:ProcessTag(tagname, filename, pattern, fielddict, 0, a:typeinfo, a:fileinfo)
    2              0.000001     endif

FUNCTION  nerdtree#runningWindows()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\autoload\nerdtree.vim line 214
Called 25044 times
Total time:   0.078363
 Self time:   0.078363

count  total (s)   self (s)
25044              0.071589     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>21_DevIconsGetArtifactFix()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-devicons\plugin\webdevicons.vim line 542
Called 12300 times
Total time:   0.065257
 Self time:   0.065257

count  total (s)   self (s)
12300              0.012511   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
12300              0.004326   else
12300              0.011855     let artifactFix = ''
12300              0.003999   endif
                            
12300              0.009560   return artifactFix

FUNCTION  gitgutter#all()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 3
Called 3 times
Total time:   0.025874
 Self time:   0.004275

count  total (s)   self (s)
    3              0.000014   let visible = tabpagebuflist()
                            
   84              0.000142   for bufnr in range(1, bufnr('$') + 1)
   81              0.000190     if buflisted(bufnr)
   15              0.002505       let file = expand('#'.bufnr.':p')
   15              0.000049       if !empty(file)
   15              0.000038         if index(visible, bufnr) != -1
    3   0.021193   0.000037           call gitgutter#process_buffer(bufnr, a:force)
   12              0.000015         elseif a:force
   12   0.000620   0.000178           call s:reset_tick(bufnr)
   15              0.000012         endif
   15              0.000008       endif
   81              0.000046     endif
   84              0.000061   endfor

FUNCTION  gitgutter#utility#extension()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 88
Called 4 times
Total time:   0.000606
 Self time:   0.000031

count  total (s)   self (s)
    4   0.000604   0.000029   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  coc#float#get_float_win_list()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 599
Called 4 times
Total time:   0.000291
 Self time:   0.000291

count  total (s)   self (s)
    4              0.000005   if s:is_vim && exists('*popup_list')
                                return filter(popup_list(), 'popup_getpos(v:val)["visible"]')
    4              0.000013   elseif has('nvim') && exists('*nvim_win_get_config')
    4              0.000003     let res = []
   22              0.000026     for i in range(1, winnr('$'))
   18              0.000024       let id = win_getid(i)
   18              0.000073       let config = nvim_win_get_config(id)
                                  " ignore border & button window
   18              0.000059       if (!empty(config) && !empty(config['relative']) && !getwinvar(id, 'target_winid', 0))
    3              0.000005         call add(res, id)
   18              0.000007       endif
   22              0.000009     endfor
    4              0.000003     return res
                              endif
                              return []

FUNCTION  246()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 306
Called 6465 times
Total time:   0.006143
 Self time:   0.006143

count  total (s)   self (s)
 6465              0.004710     return self._ignoreEnabled ==# 1

FUNCTION  <SNR>25_request()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 148
Called 8 times
Total time:   0.032012
 Self time:   0.031949

count  total (s)   self (s)
    8   0.000077   0.000046   let channel = coc#client#get_channel(self)
    8              0.000016   if empty(channel) | return '' | endif
    8              0.000005   try
    8              0.000005     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    8              0.000003     else
    8   0.031603   0.031571       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    8              0.000006   endtry

FUNCTION  coc#float#close()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 568
Called 1 time
Total time:   0.000573
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000017   0.000006   if !coc#float#valid(a:winid)
                                return 0
    1              0.000000   endif
    1   0.000234   0.000006   call coc#float#close_related(a:winid)
    1   0.000318   0.000006   call s:close_win(a:winid)
    1              0.000000   return 1

FUNCTION  coc#rpc#ready()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 31
Called 163 times
Total time:   0.000953
 Self time:   0.000953

count  total (s)   self (s)
  163              0.000533   if empty(s:client) || s:client['running'] == 0
                                return 0
  163              0.000054   endif
  163              0.000085   return 1

FUNCTION  tagbar#state#set_current_file()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\state.vim line 5
Called 6 times
Total time:   0.000073
 Self time:   0.000037

count  total (s)   self (s)
    6   0.000071   0.000035     call s:get().setCurrentFile(a:fileinfo)

FUNCTION  <SNR>51_refreshGitStatus()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 149
Called 7 times
Total time:   0.021513
 Self time:   0.000219

count  total (s)   self (s)
    7              0.000076     let l:opts =  { 'on_failed_cb': function('s:onGitStatusFailedCB'), 'on_success_cb': function('s:onGitStatusSuccessCB'), 'cwd': a:workdir }
    7   0.021422   0.000128     let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
    7              0.000005     return l:job

FUNCTION  119()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\tree_file_node.vim line 196
Called 105 times
Total time:   0.015069
 Self time:   0.000970

count  total (s)   self (s)
  105   0.000457   0.000272     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  105              0.000025     endif
                            
  105   0.014436   0.000522     return self.equals(self.getNerdtree().root)

FUNCTION  <SNR>56_dir()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 214
Called 14 times
Total time:   0.002324
 Self time:   0.000196

count  total (s)   self (s)
   14   0.002313   0.000185   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  coc#float#close_auto_hide_wins()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 736
Called 4 times
Total time:   0.000360
 Self time:   0.000069

count  total (s)   self (s)
    4   0.000316   0.000024   let winids = coc#float#get_float_win_list()
    4              0.000008   let except = get(a:, 1, 0)
    7              0.000006   for id in winids
    3              0.000003     if except && id == except
    3              0.000002       continue
                                endif
                                if getwinvar(id, 'autohide', 0)
                                  call coc#float#close(id)
                                endif
    4              0.000002   endfor

FUNCTION  gitgutter#utility#shellescape()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 73
Called 18 times
Total time:   0.000565
 Self time:   0.000463

count  total (s)   self (s)
   18              0.000255   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    4              0.000005     return a:arg
   14   0.000180   0.000078   elseif s:winshell()
   14              0.000082     return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  tagbar#debug#log()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\debug.vim line 30
Called 96 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   96              0.000082     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
   96              0.000031     endif

FUNCTION  gitgutter#async#available()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 11
Called 4 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    4              0.000004   return s:available

FUNCTION  <SNR>80_getKind()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim line 17
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                                "let idx = self.kinddict[a:kind]
    3              0.000018     let idx = has_key(self.kinddict, a:kind) ? self.kinddict[a:kind] : -1
    3              0.000007     return self.kinds[idx]

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 216
Called 101 times
Total time:   0.001562
 Self time:   0.001562

count  total (s)   self (s)
  101              0.000608   let matches = matchlist(a:line, s:hunk_re)
  101              0.000115   if len(matches) > 0
   24              0.000045     let from_line  = str2nr(matches[1])
   24              0.000060     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   24              0.000039     let to_line    = str2nr(matches[3])
   24              0.000048     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   24              0.000045     return [from_line, from_count, to_line, to_count]
   77              0.000024   else
   77              0.000040     return []
                              end

FUNCTION  <SNR>123_reset()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 106
Called 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000038     let self.mtime = getftime(self.fpath)
    1              0.000003     let self._taglist = []
    1              0.000003     let self._tagdict = {}
    1              0.000001     let self.fline = {}
    1              0.000029     let self.tline = {}
                            
    1              0.000002     let self._tagfolds_old = self.tagfolds
    1              0.000001     let self.tagfolds = {}
                            
    9              0.000007     for kind in self.typeinfo.kinds
    8              0.000012         let self.tagfolds[kind.short] = {}
    9              0.000004     endfor

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-devicons\plugin\webdevicons.vim line 491
Called 6150 times
Total time:   0.750139
 Self time:   0.717418

count  total (s)   self (s)
 6150              0.004509   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
 6150              0.001992   else
 6150              0.018872     let fileNodeExtension = fnamemodify(a:1, ':e')
 6150              0.014116     let fileNode = fnamemodify(a:1, ':t')
 6150              0.003827     if a:0 > 1
 5890              0.006158       let isDirectory = a:2
  260              0.000083     else
  260              0.000226       let isDirectory = 0
 6150              0.001814     endif
 6150              0.001781   endif
                            
 6150              0.008609   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
 6150              0.009462     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 6150              0.011402     let fileNodeExtension = tolower(fileNodeExtension)
 6150              0.009425     let fileNode = tolower(fileNode)
                            
61500              0.100063     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
55350              0.233154       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
55350              0.015546       endif
61500              0.022268     endfor
                            
 6150              0.009997     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 6150              0.012761       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
   20              0.000038         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
 6130              0.022680       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
  215              0.000439         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
 5915              0.003869       elseif isDirectory == 1
 5885              0.008816         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
 6150              0.002008       endif
 6150              0.001800     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
 6150              0.001832   endif
                            
 6150   0.068573   0.035852   let artifactFix = s:DevIconsGetArtifactFix()
                            
 6150              0.007312   return symbol . artifactFix
                            

FUNCTION  <SNR>135_syntax_stack_at()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 25
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000036   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  coc#util#check_refresh()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 61
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000010   if !bufloaded(a:bufnr)
                                return 0
    2              0.000001   endif
    2              0.000005   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    2              0.000001   endif
    2              0.000004   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    2              0.000000   endif
    2              0.000001   return 1

FUNCTION  <SNR>51_buildGitStatusCommand()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 145
Called 7 times
Total time:   0.000232
 Self time:   0.000066

count  total (s)   self (s)
    7   0.000228   0.000062     return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)

FUNCTION  gitgutter#sign#update_signs()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 57
Called 4 times
Total time:   0.000899
 Self time:   0.000707

count  total (s)   self (s)
    4              0.000008   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    4              0.000020     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    4   0.000055   0.000025     let modified_lines = s:handle_double_hunk(a:modified_lines)
    4   0.000533   0.000372     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    4              0.000007     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
    4              0.000002     endif
                            
   48              0.000027     for sign in signs
   44              0.000178       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
   48              0.000018     endfor
    4              0.000002     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  gitgutter#diff#run_diff()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 71
Called 4 times
Total time:   0.024917
 Self time:   0.000959

count  total (s)   self (s)
    4   0.000127   0.000034   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
    4              0.000002   endif
                            
    4   0.000109   0.000029   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    4              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    4              0.000004   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    4              0.000016   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    4              0.000008   let s:counter = (s:counter + 1) % 20
    4              0.000011   let buff_file .= '.'.s:counter
                            
    4   0.000637   0.000031   let extension = gitgutter#utility#extension(a:bufnr)
    4              0.000006   if !empty(extension)
    4              0.000009     let buff_file .= '.'.extension
    4              0.000002   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    4   0.001845   0.000076   call s:write_buffer(a:bufnr, buff_file)
                            
    4              0.000007   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    4              0.000043     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    4              0.000008     let from_file .= '.'.s:counter
                            
    4              0.000006     if !empty(extension)
    4              0.000007       let from_file .= '.'.extension
    4              0.000001     endif
                            
                                " Write file from index to temporary file.
    4   0.000970   0.000075     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000025     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000002   endif
                            
                              " Call git-diff.
    4              0.000013   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    4              0.000004   if s:c_flag
    4              0.000006     let cmd .= ' -c "diff.autorefreshindex=0"'
    4              0.000006     let cmd .= ' -c "diff.noprefix=false"'
    4              0.000008     let cmd .= ' -c "core.safecrlf=false"'
    4              0.000002   endif
    4              0.000023   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    4              0.000009   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    4              0.000001   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    4              0.000007   let cmd .= ' || exit 0'
                            
    4              0.000006   let cmd .= ')'
                            
    4   0.001515   0.000034   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    4   0.000028   0.000022   if g:gitgutter_async && gitgutter#async#available()
    4   0.019287   0.000259     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    4              0.000013     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitstatus#util#BuildGitStatusCommand()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 59
Called 7 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    7              0.000054     let l:cmd = [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'status', '--porcelain' . (get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2 ? '=v2' : ''), '-z' ]
    7              0.000015     if has_key(a:opts, 'NERDTreeGitStatusUntrackedFilesMode')
    7              0.000025         let l:cmd += ['--untracked-files=' . a:opts['NERDTreeGitStatusUntrackedFilesMode']]
    7              0.000003     endif
                            
    7              0.000012     if get(a:opts, 'NERDTreeGitStatusShowIgnored', 0)
                                    let l:cmd += ['--ignored=traditional']
    7              0.000002     endif
                            
    7              0.000010     if has_key(a:opts, 'NERDTreeGitStatusIgnoreSubmodules')
                                    let l:cmd += ['--ignore-submodules=' . a:opts['NERDTreeGitStatusIgnoreSubmodules']]
    7              0.000002     endif
                            
    7              0.000005     return l:cmd

FUNCTION  <SNR>77_goto_win()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3584
Called 32 times
Total time:   0.001036
 Self time:   0.000901

count  total (s)   self (s)
                                "Do not go to a popup window to avoid errors.
                                "Hence, check first if a:winnr is an integer,
                                "if this integer is equal to 0,
                                "the window is a popup window
   32              0.000068     if has('popupwin')
                                    if type(a:winnr) == type(0) && a:winnr == 0
                                        return
                                    endif
                                    if a:winnr ==# 'p' && winnr('#') == 0
                                        return
                                    endif
   32              0.000009     endif
   32              0.000096     let cmd = type(a:winnr) == type(0) ? a:winnr . 'wincmd w' : 'wincmd ' . a:winnr
   32              0.000043     let noauto = a:0 > 0 ? a:1 : 0
                            
   32   0.000306   0.000170     call tagbar#debug#log('goto_win(): ' . cmd . ', ' . noauto)
                            
   32              0.000017     if noauto
   32              0.000222         noautocmd execute cmd
                                else
                                    execute cmd
   32              0.000011     endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 9
Called 48 times
Total time:   0.000676
 Self time:   0.000676

count  total (s)   self (s)
   48              0.000074   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   48              0.000129   let ggvars = getbufvar(buffer, 'gitgutter')
   48              0.000096   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   48              0.000022   endif
   48              0.000115   let ggvars[a:varname] = a:val

FUNCTION  nerdtree#has_opt()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\autoload\nerdtree.vim line 182
Called 12527 times
Total time:   0.030863
 Self time:   0.030863

count  total (s)   self (s)
12527              0.027457     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>131_reset_summary()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 24
Called 4 times
Total time:   0.000066
 Self time:   0.000024

count  total (s)   self (s)
    4   0.000064   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>130_is_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 273
Called 24 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
   24              0.000030   return a:from_count == 0 && a:to_count > 0

FUNCTION  coc#highlight#add_highlights()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 75
Called 4 times
Total time:   0.000842
 Self time:   0.000111

count  total (s)   self (s)
                              " clear highlights
    4   0.000170   0.000019   call coc#compat#execute(a:winid, 'syntax clear')
    4              0.000007   let bufnr = winbufnr(a:winid)
    4   0.000109   0.000024   call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
    4              0.000004   if !empty(a:codes)
    4   0.000517   0.000022     call coc#highlight#highlight_lines(a:winid, a:codes)
    4              0.000001   endif
    4              0.000005   if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
    4              0.000001   endif

FUNCTION  <SNR>77_IsValidFile()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3325
Called 7 times
Total time:   0.001264
 Self time:   0.001238

count  total (s)   self (s)
    7   0.000056   0.000031     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    7              0.000010     if a:fname ==# '' || a:ftype ==# ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
    7              0.000002     endif
                            
    7              0.000447     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
    7              0.000003     endif
                            
    7              0.000297     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
    7              0.000002     endif
                            
    7              0.000251     let winnr = bufwinnr(a:fname)
    7              0.000019     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
    7              0.000002     endif
                            
    7              0.000007     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
    7              0.000002     endif
                            
    7              0.000016     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
    7              0.000002     endif
                            
    7              0.000004     return 1

FUNCTION  nerdtree#exec()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\autoload\nerdtree.vim line 169
Called 5 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    5              0.000010     let old_ei = &eventignore
    5              0.000004     if a:ignoreAll
    5              0.000023         set eventignore=all
    5              0.000002     endif
    5              0.000003     try
    5              0.000051         exec a:cmd
    5              0.000005     finally
    5              0.000012         let &eventignore = old_ei
    5              0.000003     endtry

FUNCTION  <SNR>77_do_delayed_update()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3522
Called 7 times
Total time:   0.052159
 Self time:   0.000165

count  total (s)   self (s)
    7   0.000204   0.000052     let curfile = tagbar#state#get_current_file(0)
    7              0.000009     if empty(curfile)
                                    let curfname = ''
    7              0.000002     else
    7              0.000011         let curfname = curfile.fpath
    7              0.000002     endif
                            
    8              0.000016     while !empty(s:delayed_update_files)
    1              0.000003         let fname = remove(s:delayed_update_files, 0)
    1              0.000002         let no_display = curfname !=# fname
    1   0.051853   0.000011         call s:AutoUpdate(fname, 1, no_display)
    8              0.000006     endwhile

FUNCTION  <SNR>84_has_fresh_changes()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 162
Called 7 times
Total time:   0.000088
 Self time:   0.000044

count  total (s)   self (s)
    7   0.000085   0.000041   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>103_OneScope()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 263
Called 1 time
Total time:   0.000042
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000008   0.000006   if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
                                let tok = s:PreviousToken()
                                return (count(split('for if let while with'),tok) || tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') && s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
    1   0.000020   0.000006   elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
    1              0.000002   elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                return s:PreviousToken() != ')' || s:GetPair('(', ')', 'bW', s:skip_expr)
    1              0.000000   endif

FUNCTION  <SNR>77_PrintKinds()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1994
Called 1 time
Total time:   0.001006
 Self time:   0.000495

count  total (s)   self (s)
    1   0.000008   0.000004     call tagbar#debug#log('PrintKinds called')
                            
                                " If the short or long help is being displayed then the line numbers don't
                                " match up with the length of the output list
    1              0.000002     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
    1              0.000001     let output = []
                            
    9              0.000010     for kind in a:typeinfo.kinds
    8   0.000103   0.000091         let curtags = filter(copy(a:fileinfo.getTags()), 'v:val.fields.kind ==# kind.short')
    8   0.000122   0.000069         call tagbar#debug#log('Printing kind: ' . kind.short . ', number of (top-level) tags: ' . len(curtags))
                            
    8              0.000014         if empty(curtags)
    7              0.000005             continue
    1              0.000001         endif
                            
    1              0.000008         if has_key(get(a:typeinfo, 'kind2scope', {}), kind.short)
                                        " Scoped tags
    3              0.000005             for tag in curtags
    2   0.000464   0.000022                 call s:PrintTag(tag, 0, output, a:fileinfo, a:typeinfo)
                            
    2              0.000004                 if g:tagbar_compact != 1
    2              0.000006                     call add(output, '')
    2              0.000001                 endif
    3              0.000003             endfor
                                    else
                                        " Non-scoped tags
                                        let kindtag = curtags[0].parent
                            
                                        if kindtag.isFolded()
                                            let foldmarker = g:tagbar#icon_closed
                                        else
                                            let foldmarker = g:tagbar#icon_open
                                        endif
                            
                                        let padding = g:tagbar_show_visibility ? ' ' : ''
                                        if g:tagbar_show_tag_count
                                            let tag_count = ' (' . len(curtags) . ')'
                                            call add(output, foldmarker . padding . kind.long . tag_count)
                                        else
                                            call add(output, foldmarker . padding . kind.long)
                                        endif
                            
                                        let curline                   = len(output) + offset
                                        let kindtag.tline             = curline
                                        let a:fileinfo.tline[curline] = kindtag
                            
                                        if !kindtag.isFolded()
                                            for tag in curtags
                                                let str = tag.strfmt()
                                                call add(output, repeat(' ', g:tagbar_indent) . str)
                            
                                                " Save the current tagbar line in the tag for easy
                                                " highlighting access
                                                let curline                   = len(output) + offset
                                                let tag.tline                 = curline
                                                let a:fileinfo.tline[curline] = tag
                                            endfor
                                        endif
                            
                                        if g:tagbar_compact != 1
                                            call add(output, '')
                                        endif
    1              0.000001         endif
    2              0.000006     endfor
                            
    1              0.000007     let outstr = join(output, "\n")
    1              0.000003     if g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
                                    silent 0put =outstr
    1              0.000001     else
    1              0.000046         silent  put =outstr
    1              0.000001     endif

FUNCTION  <SNR>56_not_git_dir()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 59
Called 10 times
Total time:   0.001699
 Self time:   0.000132

count  total (s)   self (s)
   10   0.001693   0.000126   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  291()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 821
Called 9 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    9              0.000026     return has_key(self._files, a:fname)

FUNCTION  <SNR>77_PrintTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2071
Called 2 times
Total time:   0.000442
 Self time:   0.000217

count  total (s)   self (s)
    2              0.000005     if g:tagbar_hide_nonpublic && get(a:tag.fields, 'access', 'public') !=# 'public'
                                    let a:tag.tline = -1
                                    return
    2              0.000001     endif
                            
                                " Print tag indented according to depth
    2   0.000246   0.000028     let tagstr = repeat(' ', a:depth * g:tagbar_indent) . a:tag.strfmt()
    2              0.000008     call add(a:output, tagstr)
                            
                                " Save the current tagbar line in the tag for easy highlighting access
    2              0.000009     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
    2              0.000007     let curline                   = len(a:output) + offset
    2              0.000004     let a:tag.tline               = curline
    2              0.000008     let a:fileinfo.tline[curline] = a:tag
                            
                                " Recursively print children
    2   0.000034   0.000027     if a:tag.isFoldable() && !a:tag.isFolded()
                                    for ckind in a:typeinfo.kinds
                                        let childfilter = 'v:val.fields.kind ==# ckind.short'
                                        if g:tagbar_hide_nonpublic
                                            let childfilter .= ' && get(v:val.fields, "access", "public") ==# "public"'
                                        endif
                                        let childtags = filter(copy(a:tag.getChildren()), childfilter)
                                        if len(childtags) > 0
                                            " Print 'kind' header of following children, but only if they
                                            " are not scope-defining tags (since those already have an
                                            " identifier)
                                            if !has_key(a:typeinfo.kind2scope, ckind.short)
                                                let indent  = (a:depth + 1) * g:tagbar_indent
                                                let indent += g:tagbar_show_visibility
                                                let indent += 1 " fold symbol
                                                call add(a:output, repeat(' ', indent) . '[' . ckind.long . ']')
                                                " Add basic tag to allow folding when on the header line
                                                let headertag = tagbar#prototypes#basetag#new(ckind.long)
                                                let headertag.parent = a:tag
                                                let headertag.fileinfo = a:tag.fileinfo
                                                let a:fileinfo.tline[len(a:output) + offset] = headertag
                                            endif
                                            for childtag in childtags
                                                call s:PrintTag(childtag, a:depth + 1, a:output, a:fileinfo, a:typeinfo)
                                            endfor
                                        endif
                                    endfor
    2              0.000002     endif

FUNCTION  coc#float#close_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 773
Called 10 times
Total time:   0.000590
 Self time:   0.000535

count  total (s)   self (s)
   10   0.000095   0.000040   if !coc#float#valid(a:winid)
                                return
   10              0.000003   endif
   10              0.000024   let timer = getwinvar(a:winid, 'timer', 0)
   10              0.000005   if timer
                                call timer_stop(timer)
   10              0.000003   endif
   10              0.000018   let kind = get(a:, 1, '')
   10              0.000020   let winids = getwinvar(a:winid, 'related', [])
   20              0.000018   for id in winids
   10              0.000007     if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
   10              0.000015     elseif nvim_win_is_valid(id)
   10              0.000026       if empty(kind) || getwinvar(id, 'kind', '') ==# kind
    1              0.000183         noa call nvim_win_close(id, 1)
   10              0.000003       endif
   10              0.000003     endif
   20              0.000011   endfor

FUNCTION  <SNR>90_convert_config_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 707
Called 4 times
Total time:   0.000456
 Self time:   0.000139

count  total (s)   self (s)
    4              0.000013   let valids = ['relative', 'win', 'anchor', 'width', 'height', 'bufpos', 'col', 'row', 'focusable', 'style']
    4   0.000331   0.000022   let result = coc#helper#dict_pick(a:config, valids)
    4              0.000008   let border = get(a:config, 'border', [])
    4   0.000025   0.000017   if !s:empty_border(border)
                                if result['relative'] ==# 'cursor' && result['row'] < 0
                                  " move top when has bottom border
                                  if get(border, 2, 0)
                                    let result['row'] = result['row'] - 1
                                  endif
                                else
                                  " move down when has top border
                                  if get(border, 0, 0) && !get(a:config, 'prompt', 0)
                                    let result['row'] = result['row'] + 1
                                  endif
                                endif
                                " move right when has left border
                                if get(border, 3, 0)
                                  let result['col'] = result['col'] + 1
                                endif
                                let result['width'] = float2nr(result['width'] + 1 - get(border,3, 0))
    4              0.000001   else
    4              0.000010     let result['width'] = float2nr(result['width'] + 1)
    4              0.000001   endif
    4              0.000008   let result['height'] = float2nr(result['height'])
    4              0.000002   return result

FUNCTION  coc#helper#min()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\helper.vim line 70
Called 24 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
   24              0.000025   let val = a:first
   52              0.000080   for i in range(0, len(a:000) - 1)
   28              0.000031     if a:000[i] < val
   12              0.000014       let val = a:000[i]
   28              0.000010     endif
   52              0.000025   endfor
   24              0.000015   return val

FUNCTION  <SNR>77_ExecuteCtagsOnFile()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1341
Called 1 time
Total time:   0.044135
 Self time:   0.000205

count  total (s)   self (s)
    1   0.000017   0.000010     call tagbar#debug#log('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
    1              0.000004     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
    1              0.000003     elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
    1              0.000000     else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
    1              0.000002         let ctags_args = []
    1              0.000003         if exists('g:tagbar_ctags_options')
                                        for value in g:tagbar_ctags_options
                                            call add(ctags_args, '--options='.value)
                                        endfor
    1              0.000000         endif
                            
                                    " universal-ctags deprecated this argument name
    1              0.000001         if s:ctags_is_uctags
    1              0.000002             let ctags_args += [ '--extras=+F' ]
                                    else
                                        let ctags_args += [ '--extra=', '--file-scope=yes' ]
    1              0.000000         endif
                            
    1              0.000006         let ctags_args  = ctags_args + [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSafet', '--sort=no', '--append=no' ]
                            
                                    " verbose if debug enabled
    1   0.000007   0.000005         if tagbar#debug#enabled()
                                        let ctags_args += [ '-V' ]
    1              0.000000         endif
                            
                                    " Include extra type definitions
    1              0.000002         if has_key(a:typeinfo, 'deffile')
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
    1              0.000000         endif
                            
                                    " Third-party programs may not necessarily make use of this
    1              0.000002         if has_key(a:typeinfo, 'ctagstype')
    1              0.000002             let ctags_type = a:typeinfo.ctagstype
                            
    1              0.000001             let ctags_kinds = ''
    9              0.000007             for kind in a:typeinfo.kinds
    8              0.000008                 if kind.short !=# '?'
    7              0.000012                     let ctags_kinds .= kind.short
    8              0.000003                 endif
    9              0.000004             endfor
                            
    1              0.000003             let ctags_args += ['--language-force=' . ctags_type]
    1              0.000003             let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
    1              0.000000         endif
    1              0.000000     endif
                            
    1              0.000002     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
    1              0.000000     else
    1              0.000002         let ctags_bin = g:tagbar_ctags_bin
    1              0.000000     endif
                            
    1   0.000296   0.000010     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
    1              0.000001     if ctags_cmd ==# ''
                                    return ''
    1              0.000000     endif
                            
    1   0.043635   0.000010     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    1              0.000010     if v:shell_error || ctags_output =~? 'Warning: cannot open \(source\|input\) file'
                                    call tagbar#debug#log('Command output:')
                                    call tagbar#debug#log(ctags_output)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr(s:TagbarBufName()) != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                        echomsg 'Exit code: ' . v:shell_error
                                    endif
                                    return -1
    1              0.000000     endif
                            
    1   0.000016   0.000010     call tagbar#debug#log('Ctags executed successfully')
    1   0.000010   0.000007     call tagbar#debug#log_ctags_output(ctags_output)
                            
    1              0.000001     return ctags_output

FUNCTION  <SNR>90_is_blocking()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1602
Called 4 times
Total time:   0.000040
 Self time:   0.000032

count  total (s)   self (s)
    4   0.000029   0.000021   if coc#prompt#activated()
                                return 1
    4              0.000001   endif
    4              0.000002   return 0

FUNCTION  <SNR>103_LookingAt()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 165
Called 5 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    5              0.000010   return getline('.')[col('.')-1]

FUNCTION  <SNR>135_syntax_at()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 30
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  gitgutter#process_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 21
Called 10 times
Total time:   0.030593
 Self time:   0.000652

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   10   0.004661   0.000065   if gitgutter#utility#is_active(a:bufnr)
                            
   10              0.000036     if has('patch-7.4.1559')
   10              0.000051       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   10              0.000004     endif
   10   0.000419   0.000079     let how = s:setup_path(a:bufnr, l:Callback)
   10              0.000019     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
   10              0.000004     endif
                            
   10   0.000130   0.000042     if a:force || s:has_fresh_changes(a:bufnr)
                            
    4              0.000005       let diff = 'NOT SET'
    4              0.000003       try
    4   0.024986   0.000069         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    4              0.000005       endtry
                            
    4              0.000013       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000002       endif
                            
   10              0.000004     endif
   10              0.000004   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 112
Called 22 times
Total time:   0.000571
 Self time:   0.000268

count  total (s)   self (s)
   22   0.000391   0.000172   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   22   0.000164   0.000080   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>125_initFoldState()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 111
Called 2 times
Total time:   0.000097
 Self time:   0.000086

count  total (s)   self (s)
    2              0.000006     let fileinfo = self.fileinfo
                            
    2   0.000047   0.000036     if a:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
    2              0.000017         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
                                elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
    2              0.000001     endif

FUNCTION  nerdtree#renderView()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\autoload\nerdtree.vim line 257
Called 5 times
Total time:   0.541950
 Self time:   0.000021

count  total (s)   self (s)
    5   0.541948   0.000019     call b:NERDTree.render()

FUNCTION  <SNR>124_maybe_map_scope()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim line 1
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000005     if !empty(g:tagbar_scopestrs)
                                    if has_key(g:tagbar_scopestrs, a:scopestr)
                                        return g:tagbar_scopestrs[a:scopestr]
                                    endif
    2              0.000001     endif
    2              0.000002     return a:scopestr

FUNCTION  gitgutter#utility#windows()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 236
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000011   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>84_reset_tick()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 166
Called 12 times
Total time:   0.000443
 Self time:   0.000165

count  total (s)   self (s)
   12   0.000429   0.000151   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>125_getClosedParentTline()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 130
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001     let tagline  = self.tline
                            
                                " Find the first closed parent, starting from the top of the hierarchy.
    1              0.000001     let parents   = []
    1              0.000001     let curparent = self.parent
    1              0.000002     while !empty(curparent)
                                    call add(parents, curparent)
                                    let curparent = curparent.parent
    1              0.000001     endwhile
    1              0.000002     for parent in reverse(parents)
                                    if parent.isFolded()
                                        let tagline = parent.tline
                                        break
                                    endif
    1              0.000001     endfor
                            
    1              0.000001     return tagline

FUNCTION  <SNR>77_ExecuteCtags()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3074
Called 1 time
Total time:   0.043625
 Self time:   0.000231

count  total (s)   self (s)
    1   0.000011   0.000006     call tagbar#debug#log('Executing ctags command: ' . a:ctags_cmd)
                            
    1              0.000003     if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
    1              0.000000     endif
                            
    1              0.000006     if &shell =~# 'elvish'
                                    " Reset shell since Elvish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
    1              0.000000     endif
                            
    1              0.000002     if exists('+shellslash')
    1              0.000002         let shellslash_save = &shellslash
    1              0.000040         set noshellslash
    1              0.000000     endif
                            
    1              0.000005     if &shell =~? 'cmd\.exe'
    1              0.000002         let shellxquote_save = &shellxquote
    1              0.000004         set shellxquote=\"
    1              0.000002         let shellcmdflag_save = &shellcmdflag
    1              0.000002         set shellcmdflag=/s\ /c
    1              0.000000     endif
                            
    1   0.000006   0.000005     if tagbar#debug#enabled()
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call tagbar#debug#log(v:statusmsg)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    redraw!
    1              0.000000     else
    1              0.000003         let py_version = get(g:, 'tagbar_python', 1)
    1   0.043405   0.000017         silent let ctags_output = s:run_system(a:ctags_cmd, py_version)
    1              0.000001     endif
                            
    1              0.000016     if &shell =~? 'cmd\.exe'
    1              0.000011         let &shellxquote  = shellxquote_save
    1              0.000004         let &shellcmdflag = shellcmdflag_save
    1              0.000001     endif
                            
    1              0.000004     if exists('+shellslash')
    1              0.000068         let &shellslash = shellslash_save
    1              0.000001     endif
                            
    1              0.000002     if exists('shell_save')
                                    let &shell = shell_save
    1              0.000000     endif
                            
    1              0.000001     return ctags_output

FUNCTION  <SNR>103_Continues()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 236
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000023   let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
    1              0.000003   if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
    1              0.000013   elseif tok !~ '[/>]'
    1              0.000002     return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')

FUNCTION  coc#float#content_height()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 749
Called 4 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    4              0.000007   if !bufloaded(a:bufnr)
                                return 0
    4              0.000001   endif
    4              0.000002   if !a:wrap
                                return has('nvim') ? nvim_buf_line_count(a:bufnr) : len(getbufline(a:bufnr, 1, '$'))
    4              0.000001   endif
    4              0.000027   let lines = has('nvim') ? nvim_buf_get_lines(a:bufnr, 0, -1, 0) : getbufline(a:bufnr, 1, '$')
    4              0.000003   let total = 0
   21              0.000016   for line in lines
   17              0.000054     let dw = max([1, strdisplaywidth(line)])
   17              0.000062     let total += float2nr(ceil(str2float(string(dw))/a:width))
   21              0.000009   endfor
    4              0.000003   return total

FUNCTION  <SNR>89_isEOF()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 128
Called 7 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    7              0.000023     return len(a:data) == 1 && a:data[0] is# ''

FUNCTION  207()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\flag_set.vim line 7
Called 6205 times
Total time:   0.073769
 Self time:   0.046978

count  total (s)   self (s)
 6205   0.048095   0.021304     let flags = self._flagsForScope(a:scope)
 6205              0.009593     if index(flags, a:flag) == -1
 6205              0.010239         call add(flags, a:flag)
 6205              0.002104     end

FUNCTION  208()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\flag_set.vim line 15
Called 12300 times
Total time:   0.027863
 Self time:   0.027863

count  total (s)   self (s)
12300              0.024484     let self._flags[a:scope] = []

FUNCTION  209()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\flag_set.vim line 20
Called 12355 times
Total time:   0.054452
 Self time:   0.054452

count  total (s)   self (s)
12355              0.021304     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
12355              0.003705     endif
12355              0.014183     return self._flags[a:scope]

FUNCTION  tagbar#is_paused()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3747
Called 39 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   39              0.000029     return s:paused

FUNCTION  212()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\flag_set.vim line 45
Called 230 times
Total time:   0.003132
 Self time:   0.003132

count  total (s)   self (s)
  230              0.000204     let flagstring = ''
  690              0.000688     for i in values(self._flags)
  460              0.000762         let flagstring .= join(i)
  690              0.000243     endfor
                            
  230              0.000247     if len(flagstring) == 0
                                    return ''
  230              0.000057     endif
                            
  230              0.000281     return '[' . flagstring . ']'

FUNCTION  218()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 101
Called 5 times
Total time:   0.000750
 Self time:   0.000066

count  total (s)   self (s)
    5   0.000323   0.000015     call g:NERDTree.MustBeOpen()
    5   0.000422   0.000047     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  219()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 108
Called 105 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
  105              0.000159     return exists('b:NERDTree')

FUNCTION  <SNR>77_HighlightTag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2214
Called 6 times
Total time:   0.060228
 Self time:   0.058341

count  total (s)   self (s)
                            
    6              0.000007     if g:tagbar_no_autocmds
                                    " If no autocmds are enabled, then it doesn't make sense to highlight
                                    " anything as the cursor can move around and any highlighting would be
                                    " inaccurate
                                    return
    6              0.000002     endif
                            
    6              0.000005     let tagline = 0
                            
    6              0.000008     let force = a:0 > 0 ? a:1 : 0
                            
    6              0.000003     if a:0 > 1
                                    let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0, a:2)
    6              0.000002     else
    6   0.001761   0.000035         let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0)
    6              0.000002     endif
    6              0.000006     if !empty(tag)
    1              0.000001         let tagline = tag.tline
    6              0.000001     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    6              0.000010     if !force && tagline ==# s:last_highlight_tline
    5              0.000002         return
    1              0.000000     else
    1              0.000001         let s:last_highlight_tline = tagline
    1              0.000000     endif
                            
    1   0.000080   0.000074     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000001     if tagbarwinnr == -1
                                    return
    1              0.000000     endif
                            
    1              0.000001     if tagbarwinnr == winnr()
                                    let in_tagbar = 1
    1              0.000000     else
    1              0.000001         let in_tagbar = 0
    1              0.000001         let prevwinnr = winnr()
    1   0.000044   0.000005         call s:goto_win('p', 1)
    1              0.000002         let pprevwinnr = winnr()
    1   0.000037   0.000005         call s:goto_win(tagbarwinnr, 1)
    1              0.000000     endif
                            
    1              0.000001     try
    1              0.000001         match none
                            
                                    " No tag above cursor position so don't do anything
    1              0.000001         if tagline == 0
                                        return
    1              0.000000         endif
                            
    1              0.000001         if g:tagbar_autoshowtag == 1 || a:openfolds
                                        call s:OpenParents(tag)
    1              0.000000         endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
    1   0.000026   0.000009         let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
    1              0.000001         if tagline <= 0
                                        return
    1              0.000000         endif
                            
                                    " Go to the line containing the tag
    1              0.000002         execute tagline
                            
                                    " Make sure the tag is visible in the window
    1              0.000002         call winline()
                            
    1              0.000003         let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                            
                                    " If printing the line number of the tag to the left, and the tag is
                                    " visible (I.E. parent isn't folded)
    1              0.000003         let identifier = '\zs\V' . escape(tag.name, '/\') . '\m\ze'
    1              0.000002         if g:tagbar_show_tag_linenumbers == 2 && tagline == tag.tline
                                        let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\[[0-9]\+\] \?' . identifier . '/'
    1              0.000000         else
    1              0.000003             let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?' . identifier . '/'
    1              0.000000         endif
    1   0.000009   0.000005         call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
    1              0.000010         if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
    1              0.000010             execute 'match TagbarHighlight ' . pattern
                                    else
                                        execute 'match Search ' . pattern
    1              0.000000         endif
    1              0.000001     finally
    1              0.000001         if !in_tagbar
    1   0.000037   0.000005             call s:goto_win(pprevwinnr, 1)
    1   0.000035   0.000005             call s:goto_win(prevwinnr, 1)
    1              0.000000         endif
    1              0.058025         redraw
    1              0.000002     endtry

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\comment.vim line 5
Called 116 times
Total time:   0.014249
 Self time:   0.006729

count  total (s)   self (s)
  116              0.000264   let line = getline(".")
  116              0.000179   let col = col('.')
  116              0.000990   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
   39              0.000098     let col = indent('.') + 1
  116              0.000060   endif
  116   0.006268   0.000892   let syn_start = s:syn_name(line('.'), col)
  116              0.000289   let save_cursor = getcurpos()
                            
  116              0.000449   if syn_start =~? '^jsx'
   57              0.000276     if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
   57   0.002612   0.000469     elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
   57              0.000371     elseif syn_start =~? '^jsxAttrib'
    2              0.000008       let &l:commentstring = '// %s'
   55              0.000021     else
   55              0.000279       let &l:commentstring = '{/* %s */}'
   57              0.000021     endif
   59              0.000024   else
   59              0.000329     let &l:commentstring = a:original
  116              0.000040   endif
                            
                              " Restore the cursor position
  116              0.000281   call setpos('.', save_cursor)

FUNCTION  tagbar#prototypes#normaltag#new()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim line 10
Called 2 times
Total time:   0.001267
 Self time:   0.000186

count  total (s)   self (s)
    2   0.001007   0.000021     let newobj = tagbar#prototypes#basetag#new(a:name)
                            
    2   0.000049   0.000030     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
    2   0.000046   0.000027     let newobj.strfmt = function(s:add_snr('s:strfmt'))
    2   0.000045   0.000026     let newobj.str = function(s:add_snr('s:str'))
    2   0.000046   0.000027     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
    2   0.000064   0.000045     let newobj.getDataType = function(s:add_snr('s:getDataType'))
                            
    2              0.000003     return newobj

FUNCTION  tagbar#debug#enabled()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\debug.vim line 46
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000003     return s:debug_enabled

FUNCTION  <SNR>51_hasPrefix()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 217
Called 7 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    7              0.000041     return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix

FUNCTION  <SNR>77_SetStatusLine()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3369
Called 6 times
Total time:   0.001823
 Self time:   0.000906

count  total (s)   self (s)
    6   0.000478   0.000444     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    6              0.000015     if tagbarwinnr == -1 || exists('g:tagbar_no_status_line')
                                    return
    6              0.000002     endif
                            
                                " Make sure we're actually in the Tagbar window
    6              0.000008     if tagbarwinnr != winnr()
    6              0.000006         let in_tagbar = 0
    6              0.000006         let prevwinnr = winnr()
    6   0.000243   0.000029         call s:goto_win('p', 1)
    6              0.000009         let pprevwinnr = winnr()
    6   0.000192   0.000027         call s:goto_win(tagbarwinnr, 1)
                                else
                                    let in_tagbar = 1
    6              0.000002     endif
                            
    6   0.000130   0.000030     if !empty(tagbar#state#get_current_file(0))
    6   0.000106   0.000025         let fileinfo = tagbar#state#get_current_file(0)
    6              0.000018         let fname = fnamemodify(fileinfo.fpath, ':t')
    6              0.000014         let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                                else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
    6              0.000002     endif
    6              0.000007     let sortstr = sorted ? 'Name' : 'Order'
                            
    6              0.000005     let flags = []
    6              0.000017     let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
    6              0.000008     let flags += g:tagbar_autoclose ? ['C'] : []
    6              0.000010     let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
    6              0.000008     let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
    6              0.000008     if exists('g:tagbar_status_func')
                                    let args = [in_tagbar, sortstr, fname, flags]
                                    let &l:statusline = call(g:tagbar_status_func, args)
    6              0.000002     else
    6              0.000008         let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
    6              0.000009         let flagstr = join(flags, '')
    6              0.000006         if flagstr !=# ''
                                        let flagstr = '[' . flagstr . '] '
    6              0.000002         endif
    6              0.000017         let text = colour . '[' . sortstr . '] ' . flagstr . fname
    6              0.000025         let &l:statusline = text
    6              0.000002     endif
                            
    6              0.000004     if !in_tagbar
    6   0.000195   0.000027         call s:goto_win(pprevwinnr, 1)
    6   0.000181   0.000024         call s:goto_win(prevwinnr, 1)
    6              0.000002     endif

FUNCTION  224()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 148
Called 22 times
Total time:   0.001414
 Self time:   0.001414

count  total (s)   self (s)
   22              0.000048     if exists('t:NERDTreeBufName')
   22              0.001350         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  225()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 164
Called 17 times
Total time:   0.001244
 Self time:   0.000082

count  total (s)   self (s)
   17   0.001236   0.000074     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  228()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 179
Called 5 times
Total time:   0.000308
 Self time:   0.000027

count  total (s)   self (s)
    5   0.000297   0.000015     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    5              0.000002     endif

FUNCTION  <SNR>125_isFoldable()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 151
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     return !empty(self._childlist)

FUNCTION  <SNR>77_EscapeCtagsCmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2942
Called 1 time
Total time:   0.000286
 Self time:   0.000266

count  total (s)   self (s)
    1   0.000012   0.000006     call tagbar#debug#log('EscapeCtagsCmd called')
    1   0.000010   0.000005     call tagbar#debug#log('ctags_bin: ' . a:ctags_bin)
    1              0.000002     if type(a:args)==type('')
                                    call tagbar#debug#log('ctags_args (is a string): ' . a:args)
    1              0.000002     elseif type(a:args)==type([])
    1   0.000014   0.000009         call tagbar#debug#log('ctags_args (is a list): ' . string(a:args))
    1              0.000000     endif
                            
    1              0.000003     if exists('+shellslash')
    1              0.000002         let shellslash_save = &shellslash
    1              0.000064         set noshellslash
    1              0.000000     endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
    1              0.000010     if &shell =~? 'cmd\.exe$' && a:ctags_bin !~# '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
    1              0.000002         let ctags_cmd = a:ctags_bin
                                else
                                    let ctags_cmd = shellescape(a:ctags_bin)
    1              0.000000     endif
                            
                                "Add additional arguments to ctags_cmd
    1              0.000002     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
    1              0.000002     elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
   11              0.000009         for arg in a:args
   10              0.000029             let ctags_cmd .= ' ' . shellescape(arg)
   11              0.000005         endfor
    1              0.000000     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
    1              0.000001     if a:0 == 1
    1              0.000004         let ctags_cmd .= ' ' . shellescape(a:1)
    1              0.000000     endif
                            
    1              0.000002     if exists('+shellslash')
    1              0.000047         let &shellslash = shellslash_save
    1              0.000001     endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
    1              0.000002     if has('multi_byte')
    1              0.000002         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
    1              0.000006         elseif $LANG !=# ''
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
    1              0.000000         endif
    1              0.000000     endif
                            
    1   0.000013   0.000008     call tagbar#debug#log('Escaped ctags command: ' . ctags_cmd)
                            
    1              0.000001     if ctags_cmd ==# ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
    1              0.000000     endif
                            
    1              0.000001     return ctags_cmd

FUNCTION  <SNR>56_dos_shell()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 173
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000010   return &shell == 'cmd.exe' || &shell == 'command.com'

FUNCTION  230()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 195
Called 6465 times
Total time:   0.022483
 Self time:   0.022483

count  total (s)   self (s)
 6465              0.009559     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
 6465              0.001569     endif
 6465              0.004337     return s:NERDTree._PathFilters

FUNCTION  233()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 213
Called 5 times
Total time:   0.541929
 Self time:   0.000022

count  total (s)   self (s)
    5   0.541927   0.000020     call self.ui.render()

FUNCTION  235()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 25
Called 5 times
Total time:   0.000482
 Self time:   0.000468

count  total (s)   self (s)
    5   0.000023   0.000016     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    5   0.000023   0.000016     elseif !self.isMinimal()
    5              0.000011         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
    5              0.000022         silent! put =help
    5              0.000002     endif

FUNCTION  <SNR>125__getPrefix()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 84
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000003     let fileinfo = self.fileinfo
                            
    2              0.000003     if !empty(self._childlist)
                                    if fileinfo.tagfolds[self.fields.kind][self.fullpath]
                                        let prefix = g:tagbar#icon_closed
                                    else
                                        let prefix = g:tagbar#icon_open
                                    endif
    2              0.000001     else
    2              0.000002         let prefix = ' '
    2              0.000001     endif
                                " Visibility is called 'access' in the ctags output
    2              0.000002     if g:tagbar_show_visibility
    2              0.000005         if has_key(self.fields, 'access')
                                        let prefix .= get(s:visibility_symbols, self.fields.access, ' ')
    2              0.000005         elseif has_key(self.fields, 'file')
                                        let prefix .= s:visibility_symbols.private
    2              0.000001         else
    2              0.000004             let prefix .= ' '
    2              0.000001         endif
    2              0.000001     endif
                            
    2              0.000003     return prefix

FUNCTION  gitgutter#diff#handler()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 173
Called 4 times
Total time:   0.007007
 Self time:   0.000333

count  total (s)   self (s)
    4   0.000173   0.000034   call gitgutter#debug#log(a:diff)
                            
    4              0.000010   if !bufexists(a:bufnr)
                                return
    4              0.000002   endif
                            
    4   0.002827   0.000068   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.002819   0.000037   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    4              0.000007   let signs_count = len(modified_lines)
    4              0.000007   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    4              0.000001   else
    4              0.000008     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    4   0.000947   0.000048       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000002     endif
    4              0.000002   endif
                            
    4   0.000127   0.000032   call s:save_last_seen_change(a:bufnr)
    4              0.000019   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    4              0.000001   endif

FUNCTION  <SNR>77_AutoUpdate()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 2783
Called 6 times
Total time:   0.116274
 Self time:   0.002004

count  total (s)   self (s)
    6   0.000078   0.000041     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    6              0.000023     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    6              0.000010     if exists('s:tagbar_qf_active')
                                    return
    6              0.000009     elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
    6              0.000002     endif
                            
                                " Get the filetype of the file we're about to process
    6              0.000305     let bufnr = bufnr(a:fname)
    6              0.000018     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    6              0.000006     if ftype ==# 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
    6              0.000002     endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    6              0.000028     let sftype = get(split(ftype, '\.'), 0, '')
    6   0.000069   0.000042     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    6   0.001076   0.000029     if !s:IsValidFile(a:fname, sftype)
                                    call tagbar#debug#log('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
    6              0.000002     endif
                            
    6              0.000005     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    6   0.000046   0.000029     if s:known_files.has(a:fname)
    6   0.000041   0.000023         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    6              0.000434         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
    1   0.000009   0.000005             call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
    1   0.048880   0.000057             call s:ProcessFile(a:fname, sftype)
    1              0.000001             let updated = 1
    5              0.000002         else
    5   0.000052   0.000030             call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
    6              0.000002         endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
    6              0.000002     endif
                            
    6              0.000004     if no_display
                                    return
    6              0.000001     endif
                            
    6   0.000039   0.000024     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    6              0.000007     if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
    6              0.000001     endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    6   0.000670   0.000479     if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
    1   0.001903   0.000008         call s:RenderContent(fileinfo)
    6              0.000002     endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    6              0.000007     if !empty(fileinfo)
    6   0.000053   0.000028         call tagbar#debug#log('Setting current file [' . a:fname . ']')
    6   0.000103   0.000030         call tagbar#state#set_current_file(fileinfo)
    6              0.000007         let s:nearby_disabled = 0
    6              0.000002     endif
                            
    6   0.060258   0.000030     call s:HighlightTag(0)
    6   0.001856   0.000034     call s:SetStatusLine()
    6   0.000044   0.000021     call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  gitstatus#util#FormatPath()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 27
Called 6150 times
Total time:   0.978637
 Self time:   0.576955

count  total (s)   self (s)
 6150              0.008887             let l:sslbak = &shellslash
 6150              0.003483             try
 6150              0.265474                 set shellslash
 6150   0.424316   0.022634                 return a:path.str()
 6150              0.003668             finally
 6150              0.262153                 let &shellslash = l:sslbak
 6150              0.004009             endtry

FUNCTION  <SNR>123_clearOldFolds()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 122
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000004     if exists('self._tagfolds_old')
    1              0.000006         unlet self._tagfolds_old
    1              0.000001     endif

FUNCTION  240()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 268
Called 5 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    5              0.000004     return self._showBookmarks

FUNCTION  243()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 283
Called 6465 times
Total time:   0.005692
 Self time:   0.005692

count  total (s)   self (s)
 6465              0.004316     return self._showHidden

FUNCTION  247()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 311
Called 15 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
   15              0.000013     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 28
Called 7 times
Total time:   0.000239
 Self time:   0.000083

count  total (s)   self (s)
    7   0.000123   0.000032   let summary = gitgutter#hunk#summary(a:bufnr)
    7              0.000009   let summary[0] += a:count
    7   0.000103   0.000037   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>129_create_namespace()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 300
Called 10 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   10              0.000014   if type(a:key) == 0
    4              0.000003     return a:key
    6              0.000002   endif
    6              0.000012   if has('nvim')
    6              0.000018     return nvim_create_namespace('coc-'.a:key)
                              endif
                              if !has_key(s:namespace_map, a:key)
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]

FUNCTION  coc#float#nvim_create_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 185
Called 4 times
Total time:   0.001983
 Self time:   0.000313

count  total (s)   self (s)
    4              0.000010   let related = getwinvar(a:winid, 'related', [])
    4              0.000007   let exists = !empty(related)
    4              0.000007   let border = get(a:opts, 'border', [])
    4              0.000007   let highlights = get(a:opts, 'borderhighlight', [])
    4              0.000007   let hlgroup = get(a:opts, 'highlight', 'CocFloating')
    4              0.000012   let borderhighlight = type(highlights) == 1 ? highlights : get(highlights, 0, 'CocFloating')
    4   0.000047   0.000025   let borderhighlight =  coc#highlight#compose_hlgroup(borderhighlight, hlgroup)
    4              0.000007   let title = get(a:opts, 'title', '')
    4              0.000009   let buttons = get(a:opts, 'buttons', [])
    4              0.000008   let pad = empty(border) || get(border, 1, 0) == 0
    4              0.000005   if get(a:opts, 'close', 0)
                                call coc#float#nvim_close_btn(a:config, a:winid, border, borderhighlight, related)
    4              0.000003   elseif exists
    3   0.000144   0.000016     call coc#float#close_related(a:winid, 'close')
    4              0.000001   endif
    4              0.000005   if !empty(buttons)
                                call coc#float#nvim_buttons(a:config, a:winid, buttons, get(border, 2, 0), pad, hlgroup, borderhighlight, related)
    4              0.000002   elseif exists
    3   0.000133   0.000015     call coc#float#close_related(a:winid, 'buttons')
    4              0.000001   endif
    4   0.000025   0.000017   if !s:empty_border(border)
                                call coc#float#nvim_border_win(a:config, a:winid, border, title, !empty(buttons), borderhighlight, related)
    4              0.000002   elseif exists
    3   0.000132   0.000017     call coc#float#close_related(a:winid, 'border')
    4              0.000001   endif
                              " Check right border
    4              0.000002   if pad
    4   0.001311   0.000031     call coc#float#nvim_right_pad(a:config, a:winid, hlgroup, related)
                              elseif exists
                                call coc#float#close_related(a:winid, 'pad')
    4              0.000001   endif
    4              0.000026   call setwinvar(a:winid, 'related', filter(related, 'nvim_win_is_valid(v:val)'))

FUNCTION  gitstatus#shouldConceal()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus.vim line 67
Called 55 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
   55              0.000119     return has('conceal') && g:NERDTreeGitStatusConcealBrackets

FUNCTION  254()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 393
Called 5 times
Total time:   0.541907
 Self time:   0.000860

count  total (s)   self (s)
    5              0.000019     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    5              0.000009     let curLine = line('.')
    5              0.000008     let curCol = col('.')
    5              0.000007     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    5              0.000238     silent 1,$delete _
                            
    5   0.000502   0.000020     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    5   0.000017   0.000013     if !self.isMinimal()
    5              0.000020         call setline(line('.')+1, '')
    5              0.000012         call cursor(line('.')+1, col('.'))
    5              0.000001     endif
                            
    5   0.000018   0.000013     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    5              0.000001     endif
                            
                                " add the 'up a dir' line
    5   0.000015   0.000010     if !self.isMinimal()
    5   0.000027   0.000023         call setline(line('.')+1, s:UI.UpDirLine())
    5              0.000009         call cursor(line('.')+1, col('.'))
    5              0.000001     endif
                            
                                " draw the header line
    5   0.001083   0.000034     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    5              0.000017     call setline(line('.')+1, header)
    5              0.000010     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    5   0.539663   0.000166     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    5              0.000044     silent 1,1delete _
                            
                                " restore the view
    5              0.000010     let old_scrolloff=&scrolloff
    5              0.000022     let &scrolloff=0
    5              0.000011     call cursor(topLine, 1)
    5              0.000049     normal! zt
    5              0.000008     call cursor(curLine, curCol)
    5              0.000011     let &scrolloff = old_scrolloff
                            
    5              0.000020     setlocal readonly nomodifiable

FUNCTION  <SNR>77_run_system()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 3037
Called 1 time
Total time:   0.043388
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000005     if has('win32') && !has('nvim') && a:version > 0 && (has('python3') || has('python2'))
                                    if a:version == 3 && has('python3')
                                        let pyx = 'py3 '
                                        let python_eval = 'py3eval'
                                    elseif a:version == 2 && has('python2')
                                        let pyx = 'py2 '
                                        let python_eval = 'pyeval'
                                    else
                                        let pyx = 'pyx '
                                        let python_eval = 'pyxeval'
                                    endif
                                    let l:pc = 0
                                    exec pyx . 'import subprocess, vim'
                                    exec pyx . '__argv = {"args":vim.eval("a:cmd"), "shell":True}'
                                    exec pyx . '__argv["stdout"] = subprocess.PIPE'
                                    exec pyx . '__argv["stderr"] = subprocess.STDOUT'
                                    exec pyx . '__argv["errors"] = "ignore"'
                                    exec pyx . '__pp = subprocess.Popen(**__argv, universal_newlines=True, encoding="utf8")'
                                    exec pyx . '__return_text = __pp.stdout.read()'
                                    exec pyx . '__pp.stdout.close()'
                                    exec pyx . '__return_code = __pp.wait()'
                                    exec 'let l:hr = '. python_eval .'("__return_text")'
                                    exec 'let l:pc = '. python_eval .'("__return_code")'
                                    let s:shell_error = l:pc
                                    return l:hr
    1              0.000000     endif
    1   0.043349   0.000016     let hr = system(a:cmd)
    1              0.000009     let s:shell_error = v:shell_error
    1              0.000002     return hr

FUNCTION  coc#highlight#clear_highlight()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 49
Called 6 times
Total time:   0.000181
 Self time:   0.000149

count  total (s)   self (s)
    6              0.000031   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    6              0.000010   if !bufloaded(bufnr)
                                return
    6              0.000002   endif
    6   0.000071   0.000039   let src_id = s:create_namespace(a:key)
    6              0.000009   if has('nvim')
    6              0.000023     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
    6              0.000002   endif

FUNCTION  gitgutter#utility#is_active()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 50
Called 10 times
Total time:   0.004596
 Self time:   0.000271

count  total (s)   self (s)
   10   0.004572   0.000247   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  262()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 528
Called 5 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    5              0.000003     return '.. (up a dir)'

FUNCTION  263()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\event.vim line 6
Called 6150 times
Total time:   0.048384
 Self time:   0.048384

count  total (s)   self (s)
 6150              0.011575     let newObj = copy(self)
 6150              0.007772     let newObj.nerdtree = a:nerdtree
 6150              0.007199     let newObj.subject = a:subject
 6150              0.006679     let newObj.action = a:action
 6150              0.006069     let newObj.params = a:params
 6150              0.004041     return newObj

FUNCTION  265()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\notifier.vim line 14
Called 6150 times
Total time:   3.357730
 Self time:   0.214351

count  total (s)   self (s)
 6150   0.077461   0.029077     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
18450   0.091110   0.033668     for Listener in s:Notifier.GetListenersForEvent(a:event)
12300              0.060007     	let Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
12300   3.088857   0.051304         call Callback(event)
18450              0.008934     endfor

FUNCTION  266()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\notifier.vim line 23
Called 6150 times
Total time:   0.024880
 Self time:   0.024880

count  total (s)   self (s)
 6150              0.010804     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
 6150              0.001904     endif
 6150              0.004746     return s:refreshListenersMap

FUNCTION  267()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\notifier.vim line 30
Called 6150 times
Total time:   0.057442
 Self time:   0.032561

count  total (s)   self (s)
 6150   0.044036   0.019156     let listenersMap = s:Notifier.GetListenersMap()
 6150              0.011105     return get(listenersMap, a:name, [])

FUNCTION  <SNR>129_execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 292
Called 7 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    7              0.000012   if has('nvim')
    7              0.000087     execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
    7              0.000003   endif

FUNCTION  tagbar#debug#log_ctags_output()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\debug.vim line 38
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001     if s:debug_enabled
                                    exe 'redir! > ' . s:debug_file . '.ctags_out'
                                    silent echon a:output
                                    redir END
    1              0.000000     endif

FUNCTION  271()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\log.vim line 24
Called 7 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    7              0.000016     if a:level < self.level
    7              0.000005         return
                                endif
                                echomsg '[nerdtree-git-status] ' . a:msg

FUNCTION  272()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\log.vim line 31
Called 7 times
Total time:   0.000542
 Self time:   0.000485

count  total (s)   self (s)
    7   0.000535   0.000478     echohl LineNr | call self.output(s:debug, a:msg) | echohl None

FUNCTION  278()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 31
Called 6150 times
Total time:   1.265429
 Self time:   0.019715

count  total (s)   self (s)
 6150   1.263579   0.017865     call self.callback(a:event)

FUNCTION  279()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 35
Called 6150 times
Total time:   1.245715
 Self time:   0.085124

count  total (s)   self (s)
 6150              0.007195     let l:path = a:event.subject
 6150   1.169030   0.021641     let l:indicator = self.getIndicatorByPath(l:path)
 6150   0.030384   0.017938     call l:path.flagSet.clearFlags('git')
 6150              0.005354     if l:indicator !=# ''
   55   0.000325   0.000190         if gitstatus#shouldConceal()
                                        let l:indicator = printf(' %s ', l:indicator)
   55              0.000019         endif
   55   0.000788   0.000168         call l:path.flagSet.addFlag('git', l:indicator)
 6150              0.001637     endif

FUNCTION  coc#util#set_buf_var()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 842
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000012   if !bufloaded(a:bufnr) | return | endif
    2              0.000013   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  <SNR>103_PreviousToken()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 173
Called 1 time
Total time:   0.000061
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000004   let [l:pos, tok] = [getpos('.'), '']
    1              0.000011   if search('\m\k\{1,}\|\S','ebW')
    1              0.000004     if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
    1              0.000000     else
    1              0.000005       let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
    1              0.000001       if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
    1              0.000000       else
    1   0.000021   0.000005         let tok = s:Token()
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   return tok

FUNCTION  <SNR>88_getStatusKey()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 149
Called 35 times
Total time:   0.000484
 Self time:   0.000484

count  total (s)   self (s)
   35              0.000071     let l:xy = a:x . a:y
   35              0.000063     if get(s:unmerged_status, l:xy, 0)
                                    return 'Unmerged'
   35              0.000032     elseif l:xy ==# '??'
                                    return 'Untracked'
   35              0.000027     elseif l:xy ==# '!!'
                                    return 'Ignored'
   35              0.000027     elseif a:y ==# 'M'
   21              0.000014         return 'Modified'
   14              0.000010     elseif a:y ==# 'D'
                                    return 'Deleted'
   14              0.000046     elseif a:y =~# '[RC]'
                                    return 'Renamed'
   14              0.000011     elseif a:x ==# 'D'
                                    return 'Deleted'
   14              0.000042     elseif a:x =~# '[MA]'
   14              0.000009         return 'Staged'
                                elseif a:x =~# '[RC]'
                                    return 'Renamed'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 765
Called 116 times
Total time:   0.003315
 Self time:   0.001751

count  total (s)   self (s)
  116   0.002768   0.001204   let id = coc#float#get_related(a:winid, 'scrollbar')
  116              0.000169   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  116              0.000040   endif

FUNCTION  <SNR>125_getChildren()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim line 216
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004     return self._childlist

FUNCTION  <SNR>127_compare_by_kind()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\sorting.vim line 21
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003     let typeinfo = s:compare_typeinfo
                            
    1              0.000004     if !has_key(typeinfo.kinddict, a:tag1.fields.kind)
                                    return -1
    1              0.000001     endif
    1              0.000003     if !has_key(typeinfo.kinddict, a:tag2.fields.kind)
                                    return 1
    1              0.000000     endif
    1              0.000004     if typeinfo.kinddict[a:tag1.fields.kind] <# typeinfo.kinddict[a:tag2.fields.kind]
                                    return -1
    1              0.000003     elseif typeinfo.kinddict[a:tag1.fields.kind] ># typeinfo.kinddict[a:tag2.fields.kind]
                                    return 1
    1              0.000001     else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
    1              0.000003         if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
    1              0.000001         else
    1              0.000002             let name1 = a:tag1.name
    1              0.000000         endif
    1              0.000002         if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
    1              0.000000         else
    1              0.000002             let name2 = a:tag2.name
    1              0.000000         endif
                            
    1              0.000002         let ci = g:tagbar_case_insensitive
    1              0.000004         if (((!ci) && (name1 <=# name2)) || (ci && (name1 <=? name2)))
                                        return -1
    1              0.000000         else
    1              0.000001             return 1
                                    endif
                                endif

FUNCTION  241()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 273
Called 6450 times
Total time:   0.005727
 Self time:   0.005727

count  total (s)   self (s)
 6450              0.004338     return self._showFiles

FUNCTION  242()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\ui.vim line 278
Called 5 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    5              0.000005     return self._showHelp

FUNCTION  <SNR>135_start_syntax()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 40
Called 1 time
Total time:   0.000035
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000034   0.000017   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  gitstatus#util#UpdateParentDirsStatus()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 203
Called 42 times
Total time:   0.001297
 Self time:   0.001297

count  total (s)   self (s)
   42              0.000146     let l:dirtyPath = fnamemodify(a:pathStr, ':h')
   42              0.000103     let l:dir_dirty_only = get(a:opts, 'NERDTreeGitStatusDirDirtyOnly', 1)
   77              0.000106     while l:dirtyPath !=# a:root
   70              0.000147         let l:key = get(a:cache, l:dirtyPath, '')
   70              0.000064         if l:dir_dirty_only
   70              0.000059             if l:key ==# ''
   35              0.000068                 let a:cache[l:dirtyPath] = 'Dirty'
   35              0.000014             else
   35              0.000017                 return
   35              0.000012             endif
                                    else
                                        if l:key ==# ''
                                            let a:cache[l:dirtyPath] = a:statusKey
                                        elseif l:key ==# 'Dirty' || l:key ==# a:statusKey
                                            return
                                        else
                                            let a:cache[l:dirtyPath] = 'Dirty'
                                        endif
   35              0.000011         endif
   35              0.000090         let l:dirtyPath = fnamemodify(l:dirtyPath, ':h')
   42              0.000024     endwhile

FUNCTION  <SNR>77_RenderContent()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1878
Called 1 time
Total time:   0.001896
 Self time:   0.000462

count  total (s)   self (s)
    1   0.000009   0.000004     call tagbar#debug#log('RenderContent called')
    1              0.000002     let s:new_window = 0
                            
    1              0.000001     if a:0 == 1
    1              0.000001         let fileinfo = a:1
                                else
                                    let fileinfo = tagbar#state#get_current_file(0)
    1              0.000000     endif
                            
    1              0.000001     if empty(fileinfo)
                                    call tagbar#debug#log('Empty fileinfo, returning')
                                    return
    1              0.000000     endif
                            
    1   0.000070   0.000064     let tagbarwinnr = bufwinnr(s:TagbarBufName())
                            
    1              0.000002     if &filetype ==# 'tagbar'
                                    let in_tagbar = 1
    1              0.000000     else
    1              0.000001         let in_tagbar = 0
    1              0.000001         let prevwinnr = winnr()
                            
                                    " Get the previous window number, so that we can reproduce
                                    " the window entering history later. Do not run autocmd on
                                    " this command, make sure nothing is interfering.
                                    " let pprevwinnr = winnr('#') " Messes up windows for some reason
    1   0.000051   0.000005         call s:goto_win('p', 1)
    1              0.000002         let pprevwinnr = winnr()
    1   0.000036   0.000005         call s:goto_win(tagbarwinnr, 1)
    1              0.000000     endif
                            
    1   0.000051   0.000011     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    " We're redisplaying the same file, so save the view
    1   0.000009   0.000005         call tagbar#debug#log('Redisplaying file [' . fileinfo.fpath . ']')
    1              0.000002         let saveline = line('.')
    1              0.000001         let savecol  = col('.')
    1              0.000002         let topline  = line('w0')
    1              0.000000     endif
                            
    1              0.000002     let lazyredraw_save = &lazyredraw
    1              0.000004     set lazyredraw
    1              0.000001     let eventignore_save = &eventignore
    1              0.000003     set eventignore=all
                            
    1              0.000002     setlocal modifiable
                            
    1              0.000058     silent %delete _
                            
    1   0.000069   0.000006     call s:PrintHelp()
                            
    1              0.000002     let typeinfo = fileinfo.typeinfo
                            
    1              0.000001     if fileinfo.fsize_exceeded == 1
                                    if g:tagbar_compact
                                        silent 0put ='\" File size [' . fileinfo.fsize . 'B] exceeds limit'
                                    else
                                        silent put ='\" File size exceeds defined limit'
                                        silent put ='\"   File Size [' . fileinfo.fsize . ' bytes]'
                                        silent put ='\"   Limit     [' . g:tagbar_file_size_limit . ' bytes]'
                                        silent put ='\" Use TagbarForceUpdate override'
                                    endif
    1   0.000007   0.000006     elseif !empty(fileinfo.getTags())
                                    " Print tags
    1   0.001014   0.000009         call s:PrintKinds(typeinfo, fileinfo)
                                else
                                    call tagbar#debug#log('No tags found, skipping printing.')
                                    if g:tagbar_compact && s:short_help
                                        silent 0put ='\" No tags found.'
                                    else
                                        silent  put ='\" No tags found.'
                                    endif
    1              0.000001     endif
                            
                                " Delete empty lines at the end of the buffer
    2              0.000010     for linenr in range(line('$'), 1, -1)
    2              0.000018         if getline(linenr) =~# '^$'
    1              0.000026             execute 'silent ' . linenr . 'delete _'
    1              0.000001         else
    1              0.000001             break
    1              0.000001         endif
    2              0.000004     endfor
                            
    1              0.000008     setlocal nomodifiable
                            
    1   0.000143   0.000034     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
    1              0.000003         let scrolloff_save = &scrolloff
    1              0.000006         setlocal scrolloff=0
                            
    1              0.000004         call cursor(topline, 1)
    1              0.000018         normal! zt
    1              0.000004         call cursor(saveline, savecol)
                            
    1              0.000006         let &l:scrolloff = scrolloff_save
                                else
                                    " Make sure as much of the Tagbar content as possible is shown in the
                                    " window by jumping to the top after drawing
                                    execute 1
                                    call winline()
                            
                                    " Invalidate highlight cache from old file
                                    let s:last_highlight_tline = 0
    1              0.000001     endif
                            
    1              0.000005     let &lazyredraw  = lazyredraw_save
    1              0.000005     let &eventignore = eventignore_save
                            
    1              0.000001     if !in_tagbar
    1   0.000095   0.000012         call s:goto_win(pprevwinnr, 1)
    1   0.000068   0.000027         call s:goto_win(prevwinnr, 1)
    1              0.000000     endif

FUNCTION  280()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 47
Called 6150 times
Total time:   1.147389
 Self time:   0.135354

count  total (s)   self (s)
 6150   1.009843   0.031206     let l:pathStr = gitstatus#util#FormatPath(a:path)
 6150              0.016106     let l:statusKey = get(self.current, l:pathStr, '')
                            
 6150              0.005810     if l:statusKey !=# ''
   55   0.000478   0.000242         return gitstatus#getIndicator(l:statusKey)
 6095              0.001779     endif
                            
 6095   0.038994   0.021446     if self.getOption('ShowClean', 0)
                                    return gitstatus#getIndicator('Clean')
 6095              0.001641     endif
                            
 6095   0.038110   0.022497     if self.getOption('ConcealBrackets', 0) && self.getOption('AlignIfConceal', 0)
                                    return ' '
 6095              0.001554     endif
 6095              0.002873     return ''

FUNCTION  281()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 65
Called 7 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    7              0.000029     let self.next = a:cache

FUNCTION  283()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 73
Called 7 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    7              0.000040     return self.current !=# self.next

FUNCTION  285()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 81
Called 7 times
Total time:   0.000660
 Self time:   0.000076

count  total (s)   self (s)
    7   0.000569   0.000028     if !g:NERDTree.IsOpen()
                                    return
    7              0.000003     endif
                            
    7   0.000071   0.000027     if !self.changed()
    7              0.000003         return
                                endif
                            
                                call self.update()
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                try
                                    call g:NERDTree.CursorToTreeWin()
                                    call b:NERDTree.root.refreshFlags()
                                    call NERDTreeRender()
                                finally
                                    noautocmd exec l:altwinnr . 'wincmd w'
                                    noautocmd exec l:winnr . 'wincmd w'
                                endtry

FUNCTION  286()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 105
Called 12190 times
Total time:   0.033162
 Self time:   0.033162

count  total (s)   self (s)
12190              0.030085     return get(self.opts, 'NERDTreeGitStatus' . a:name, a:default)

FUNCTION  289()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 805
Called 15 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   15              0.000033     return get(self._files, a:fname, {})

FUNCTION  coc#rpc#notify()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 95
Called 155 times
Total time:   0.010682
 Self time:   0.002078

count  total (s)   self (s)
  155   0.001579   0.000674   if !coc#rpc#ready()
                                return ''
  155              0.000048   endif
  155   0.008665   0.000966   call s:client['notify'](a:method, a:args)
  155              0.000129   return ''

FUNCTION  <SNR>56_is_file_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 63
Called 10 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   10              0.000036   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  coc#float#valid()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 175
Called 22 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   22              0.000020   if a:winid <= 0
                                return 0
   22              0.000008   endif
   22              0.000036   if has('nvim')
   22              0.000052     return nvim_win_is_valid(a:winid) ? 1 : 0
                              endif
                              return s:popup_visible(a:winid)

FUNCTION  <SNR>82_get()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\state.vim line 13
Called 45 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
   45              0.000087     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
   45              0.000016     endif
                            
   45              0.000035     return t:tagbar_state

FUNCTION  coc#highlight#highlight_lines()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 101
Called 4 times
Total time:   0.000496
 Self time:   0.000375

count  total (s)   self (s)
    4              0.000006   let currwin = win_getid()
    4              0.000008   if has('nvim') && currwin != a:winid
    4              0.000018     noa call nvim_set_current_win(a:winid)
    4              0.000001   endif
    4              0.000004   let defined = []
    4              0.000003   let region_id = 1
   11              0.000011   for config in a:blocks
    7              0.000012     let start = config['startLine'] + 1
    7              0.000026     let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
    7              0.000016     let filetype = get(config, 'filetype', '')
    7              0.000012     let hlGroup = get(config, 'hlGroup', '')
    7              0.000008     if !empty(hlGroup)
    7   0.000176   0.000055       call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
                                else
                                  let filetype = matchstr(filetype, '\v[^.]*')
                                  if index(defined, filetype) == -1
                                    call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
                                    call add(defined, filetype)
                                  endif
                                  call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype))
                                  let region_id = region_id + 1
    7              0.000002     endif
   11              0.000007   endfor
    4              0.000006   if has('nvim')
    4              0.000021     noa call nvim_set_current_win(currwin)
    4              0.000002   endif

FUNCTION  290()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 811
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
    1              0.000000     else
    1              0.000002         let fname = a:fileinfo.fpath
    1              0.000003         let self._files[fname] = a:fileinfo
    1              0.000000     endif

FUNCTION  294()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\state.vim line 32
Called 39 times
Total time:   0.000251
 Self time:   0.000212

count  total (s)   self (s)
   39   0.000200   0.000161     if !tagbar#is_paused() || a:force_current
   39              0.000032         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  295()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\state.vim line 41
Called 6 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    6              0.000009     let self._current = a:fileinfo

FUNCTION  297()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 37
Called 14 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
   14              0.000090     let self.chunks[-1] .= a:data[0]
   14              0.000047     call extend(self.chunks, a:data[1:])

FUNCTION  298()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 42
Called 7 times
Total time:   0.000119
 Self time:   0.000092

count  total (s)   self (s)
    7   0.000079   0.000052     let self.failed = self.failed || !s:isEOF(a:data)
    7              0.000016     let self.err_chunks[-1] .= a:data[0]
    7              0.000018     call extend(self.err_chunks, a:data[1:])

FUNCTION  299()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 48
Called 7 times
Total time:   0.005571
 Self time:   0.000075

count  total (s)   self (s)
    7              0.000015     let self.running = 0
    7              0.000008     if self.failed
                                    call self.onFailed()
    7              0.000004     else
    7   0.005521   0.000026         call self.onSuccess()
    7              0.000002     endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 21
Called 67 times
Total time:   0.000583
 Self time:   0.000583

count  total (s)   self (s)
   67              0.000170   let ggvars = getbufvar(a:buffer, 'gitgutter')
   67              0.000254   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   57              0.000078     return ggvars[a:varname]
   10              0.000003   endif
   10              0.000007   if a:0
   10              0.000007     return a:1
                              endif

FUNCTION  <SNR>77_add_tag_recursive()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar.vim line 1646
Called 2 times
Total time:   0.000314
 Self time:   0.000257

count  total (s)   self (s)
                                " If the pathlist is empty we are at the correct scope for the current tag
    2              0.000006     if empty(a:pathlist)
                                    " If a child tag got processed before a parent tag then there will
                                    " be a pseudotag here as a placeholder. Copy the children over and
                                    " then replace the pseudotag with the real one.
    2              0.000005         let pseudotags = []
    2              0.000005         if empty(a:parent)
    2   0.000044   0.000032             let name_siblings = a:taginfo.fileinfo.getTagsByName(a:taginfo.name)
                                    else
                                        let name_siblings = a:parent.getChildrenByName(a:taginfo.name)
    2              0.000002         endif
                            
                                    " Consider a tag as replaceable if the current tag is considered to
                                    " have more appropriate information
    2              0.000006         for tag in name_siblings
                                        if (tag.fields.kind ==# '?' || tag.fields.kind ==# a:taginfo.fields.kind) && (tag.isPseudoTag() || (!a:taginfo.isSplitTag() && tag.isSplitTag()))
                                            call add(pseudotags, tag)
                                        endif
    2              0.000003         endfor
                            
    2              0.000005         if len(pseudotags) == 1
                                        let pseudotag = pseudotags[0]
                                        for child in pseudotag.getChildren()
                                            call a:taginfo.addChild(child)
                                            let child.parent = a:taginfo
                                        endfor
                                        if empty(a:parent)
                                            call a:taginfo.fileinfo.removeTag(pseudotag)
                                        else
                                            call a:parent.removeChild(pseudotag)
                                        endif
    2              0.000005         elseif len(pseudotags) > 1
                                        echoerr 'Tagbar: Found duplicate pseudotag; this should never happen!' 'Please contact the script maintainer with an example.' 'Pseudotag name:' pseudotag.name
    2              0.000001         endif
                            
                                    " If this is a tag that got created due to splitting up a tag name,
                                    " don't replace existing tags of the same kind.
    2   0.000023   0.000020         if a:taginfo.isSplitTag()
                                        for tag in name_siblings
                                            if tag.fields.kind ==# a:taginfo.fields.kind
                                                return
                                            endif
                                        endfor
    2              0.000001         endif
                            
    2              0.000005         if empty(a:parent)
    2   0.000066   0.000024             call a:taginfo.fileinfo.addTag(a:taginfo)
                                    else
                                        call a:parent.addChild(a:taginfo)
                                        let a:taginfo.parent = a:parent
    2              0.000001         endif
    2              0.000002         return
                                endif
                            
                            
                                " There is still at least one more scope between the current one and the
                                " one of the current tag, so we have to either find or create the
                                " intermediate tags
                            
                                let grandparent = a:parent
                                let parentname = remove(a:pathlist, 0)
                            
                                if empty(grandparent)
                                    let name_siblings = a:taginfo.fileinfo.getTagsByName(parentname)
                                else
                                    let name_siblings = grandparent.getChildrenByName(parentname)
                                endif
                                if empty(a:pathlist)
                                    " If the current tag is a direct child of the parent we're looking for
                                    " then we can also filter the parents based on the scope information
                                    let parents = []
                                    for tag in name_siblings
                                        if tag.fields.kind ==# '?' || get(a:taginfo.typeinfo.kind2scope, tag.fields.kind, '') ==# a:taginfo.scope
                                            call add(parents, tag)
                                        endif
                                    endfor
                                else
                                    let parents = name_siblings
                                endif
                            
                                if empty(parents)
                                    " No parents found, so either the parent is a pseudotag or it hasn't
                                    " been processed yet. Create a pseudotag as a placeholder; if the
                                    " actual parent gets processed later it will get replaced.
                                    if empty(a:pathlist)
                                        let pseudokind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    else
                                        let pseudokind = '?'
                                    endif
                                    let parent = s:create_pseudotag(parentname, grandparent, pseudokind, a:taginfo.typeinfo, a:taginfo.fileinfo)
                                    if empty(grandparent)
                                        call a:taginfo.fileinfo.addTag(parent)
                                    else
                                        call grandparent.addChild(parent)
                                    endif
                                elseif len(parents) == 1
                                    let parent = parents[0]
                                else
                                    " If there are multiple possible parents (c.f. issue #139, or tags
                                    " with the same name but a different kind) then we will pick the one
                                    " that is closest above the current tag as a heuristic.
                            
                                    " Start at line 0 so that pseudotags get included
                                    let minline = 0
                                    for candidate in parents
                                        " If the line number of the current tag is 0 then we have no way
                                        " of determining the best candidate by comparing line numbers.
                                        " Just use the first one we have.
                                        if a:taginfo.fields.line == 0
                                            let parent = candidate
                                            break
                                        endif
                            
                                        if candidate.fields.line <= a:taginfo.fields.line && candidate.fields.line >= minline
                                            let parent = candidate
                                            let minline = candidate.fields.line
                                        endif
                                    endfor
                            
                                    if !exists('parent')
                                        " If we still haven't found a parent it must be below the current
                                        " tag, so find the closest parent below the tag. This can happen
                                        " for example in Go.
                                        let maxline = line('$')
                                        for candidate in parents
                                            if candidate.fields.line >= a:taginfo.fields.line && candidate.fields.line <= maxline
                                                let parent = candidate
                                                let maxline = candidate.fields.line
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                " If the parent is a pseudotag it may have gotten created as an in-between
                                " tag without proper information about its kind because all if its
                                " children are also pseudotags, so it may be incorrect. If the current tag
                                " is a direct child of a pseudotag then we can derive the correct kind, so
                                " replace it if necessary.
                                if parent.isPseudoTag() && empty(a:pathlist)
                                    let parentkind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    if parent.fields.kind ==# '?' || parentkind !=# parent.fields.kind
                                        let parent.fields.kind = parentkind
                                        call parent.initFoldState(s:known_files)
                                    endif
                                endif
                            
                                call s:add_tag_recursive(parent, a:taginfo, a:pathlist)

FUNCTION  <SNR>67_Highlight_Matching_Pair()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\plugin\matchparen.vim line 39
Called 133 times
Total time:   0.010159
 Self time:   0.010159

count  total (s)   self (s)
                              " Remove any previous match.
  133              0.000391   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  133              0.000047   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  133              0.000446   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  133              0.000039   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  133              0.000226   let c_lnum = line('.')
  133              0.000209   let c_col = col('.')
  133              0.000140   let before = 0
                            
  133              0.000278   let text = getline(c_lnum)
  133              0.002474   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  133              0.000201   if empty(matches)
                                let [c_before, c] = ['', '']
  133              0.000065   else
  133              0.000426     let [c_before, c] = matches[1:2]
  133              0.000060   endif
  133              0.001848   let plist = split(&matchpairs, '.\zs[:,]')
  133              0.000368   let i = index(plist, c)
  133              0.000106   if i < 0
                                " not found, in Insert mode try character before the cursor
  133              0.000314     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   13              0.000022       let before = strlen(c_before)
   13              0.000011       let c = c_before
   13              0.000018       let i = index(plist, c)
  133              0.000049     endif
  133              0.000086     if i < 0
                                  " not found, nothing to do
  133              0.000083       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  GetJavascriptIndent()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 350
Called 1 time
Total time:   0.000567
 Self time:   0.000311

count  total (s)   self (s)
    1   0.000086   0.000027   call s:GetVars()
    1              0.000010   let s:synid_cache = [[],[]]
    1              0.000004   let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
    1              0.000041   let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
    1              0.000007   if s:stack[-1] =~? 'comment\|doc'
                                if l:line !~ '^\s*\/[/*]'
                                  return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
                                endif
    1              0.000008   elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
    1              0.000000   endif
                            
    1              0.000004   let nest = get(get(b:,'hi_indent',{}),'blocklnr')
    1              0.000005   let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
    1              0.000002   call cursor(v:lnum,1)
    1   0.000068   0.000007   if s:PreviousToken() is ''
                                return
    1              0.000000   endif
    1              0.000006   let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
                            
    1              0.000005   let l:line = substitute(l:line,'^\s*','','')
    1              0.000001   let l:line_s = l:line[0]
    1              0.000001   if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
    1              0.000000   endif
    1              0.000003   if l:line =~ '^\/[/*]'
                                let l:line = ''
    1              0.000000   endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000002   call cursor(v:lnum,1)
    1              0.000003   let idx = index([']',')','}'],l:line[0])
    1   0.000027   0.000007   if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum || b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
    1              0.000004     call call('cursor',b:js_cache[1:])
                              else
                                let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0, max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
                                try
                                  if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                  elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
                                      return indent(l:lnum)
                                    endif
                                  else
                                    call s:AlternatePair()
                                  endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
                                endtry
                                let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
    1              0.000000   endif
                            
    1              0.000003   let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
    1   0.000010   0.000009   let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
    1              0.000002   if !num || s:LookingAt() == '{' && s:IsBlock()
    1              0.000002     let ilnum = line('.')
    1              0.000002     if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
    1              0.000000     endif
    1              0.000003     if idx == -1 && pline[-1:] !~ '[{;]'
    1              0.000002       call cursor(l:lnum, lcol)
    1              0.000010       let sol = matchstr(l:line,s:opfirst)
    1              0.000004       if sol is '' || sol == '/' && s:SynAt(v:lnum, 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
    1   0.000049   0.000005         if s:Continues()
                                      let is_op = s:sw()
    1              0.000000         endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' && s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) && s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) && (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' && s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
    1              0.000000       endif
    1              0.000002       call cursor(l:lnum, lcol)
    1   0.000085   0.000014       let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
    1              0.000000     endif
                              elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
    1              0.000000   endif
                            
                              " main return
    1              0.000005   if l:line =~ '^[])}]\|^|}'
                                if l:line_s == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
    1              0.000000   elseif num
                                return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
    1              0.000001   elseif nest
                                return indent(nextnonblank(nest+1)) + b_l + is_op
    1              0.000000   endif
    1              0.000001   return b_l + is_op

FUNCTION  <SNR>123_sortTags()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 129
Called 1 time
Total time:   0.000165
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000005     if get(a:compare_typeinfo, 'sort', g:tagbar_sort)
    1   0.000155   0.000013         call tagbar#sorting#sort(self._taglist, 'kind', a:compare_typeinfo)
                                else
                                    call tagbar#sorting#sort(self._taglist, 'line', a:compare_typeinfo)
    1              0.000001     endif

FUNCTION  coc#float#nvim_scrollbar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 351
Called 4 times
Total time:   0.000577
 Self time:   0.000237

count  total (s)   self (s)
    4   0.000072   0.000040   if !has('nvim-0.4.0') || !coc#float#valid(a:winid) || getwinvar(a:winid, 'target_winid', 0)
                                return
    4              0.000001   endif
    4              0.000023   let config = nvim_win_get_config(a:winid)
    4              0.000014   let [row, column] = nvim_win_get_position(a:winid)
    4              0.000007   let width = nvim_win_get_width(a:winid)
    4              0.000007   let height = nvim_win_get_height(a:winid)
    4              0.000006   let bufnr = winbufnr(a:winid)
    4              0.000012   let cw = getwinvar(a:winid, '&foldcolumn', 0) ? width - 1 : width
    4   0.000261   0.000032   let ch = coc#float#content_height(bufnr, cw, getwinvar(a:winid, '&wrap'))
    4   0.000065   0.000020   let closewin = coc#float#get_related(a:winid, 'close')
    4              0.000008   let border = getwinvar(a:winid, 'border', [])
    4              0.000008   let move_down = closewin && !get(border, 0, 0)
    4              0.000002   if move_down
                                let height = height - 1
    4              0.000001   endif
    4   0.000051   0.000017   let id = coc#float#get_related(a:winid, 'scrollbar')
    4              0.000004   if ch <= height || height <= 0
                                " no scrollbar, remove exists
    4              0.000002     if id
                                  call s:close_win(id)
    4              0.000001     endif
    4              0.000002     return
                              endif
                              call coc#float#close_related(a:winid, 'pad')
                              let sbuf = id ? winbufnr(id) : 0
                              let sbuf = coc#float#create_buf(sbuf, repeat([' '], height))
                              let opts = { 'row': move_down ? row + 1 : row, 'col': column + width, 'relative': 'editor', 'width': 1, 'height': height, 'focusable': v:false, 'style': 'minimal', }
                              if id
                                call nvim_win_set_config(id, opts)
                              else
                                let id = nvim_open_win(sbuf, 0 , opts)
                                if id == 0
                                  return
                                endif
                                call setwinvar(id, 'kind', 'scrollbar')
                                call setwinvar(id, 'target_winid', a:winid)
                              endif
                              let thumb_height = max([1, float2nr(floor(height * (height + 0.0)/ch))])
                              let wininfo = getwininfo(a:winid)[0]
                              let start = 0
                              if wininfo['topline'] != 1
                                " needed for correct getwininfo
                                let firstline = wininfo['topline']
                                let lastline = s:nvim_get_botline(firstline, height, cw, bufnr)
                                let linecount = nvim_buf_line_count(winbufnr(a:winid))
                                if lastline >= linecount
                                  let start = height - thumb_height
                                else
                                  let start = max([1, float2nr(round((height - thumb_height + 0.0)*(firstline - 1.0)/(ch - height)))])
                                endif
                              endif
                              " add highlights
                              call nvim_buf_clear_namespace(sbuf, -1, 0, -1)
                              for idx in range(0, height - 1)
                                if idx >= start && idx < start + thumb_height
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuThumb', idx, 0, 1)
                                else
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuSbar', idx, 0, 1)
                                endif
                              endfor
                              call s:add_related(id, a:winid)

FUNCTION  coc#float#nvim_right_pad()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 281
Called 4 times
Total time:   0.001279
 Self time:   0.000769

count  total (s)   self (s)
    4   0.000052   0.000020   let winid = coc#float#get_related(a:winid, 'pad')
    4              0.000027   let config = { 'relative': a:config['relative'], 'width': 1, 'height': a:config['height'], 'row': a:config['row'], 'col': a:config['col'] + a:config['width'], 'focusable': v:false, 'style': 'minimal', }
    4              0.000002   if winid
    3              0.000448     noa call nvim_win_close(winid, 1)
    4              0.000002   endif
    4   0.000515   0.000036   let bufnr = coc#float#create_buf(0, repeat([''], a:config['height']))
    4              0.000125   let winid = nvim_open_win(bufnr, 0, config)
    4              0.000002   if winid
                                " neovim'bug: the content shown in window could be wired.
    4              0.000015     call setwinvar(winid, '&foldcolumn', 1)
    4              0.000052     call setwinvar(winid, '&winhl', 'FoldColumn:'.a:hlgroup)
    4              0.000009     call setwinvar(winid, 'target_winid', a:winid)
    4              0.000006     call setwinvar(winid, 'kind', 'pad')
    4              0.000006     call add(a:related, winid)
    4              0.000002   endif

FUNCTION  <SNR>124_strfmt()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim line 28
Called 2 times
Total time:   0.000218
 Self time:   0.000139

count  total (s)   self (s)
    2              0.000005     let typeinfo = self.typeinfo
                            
    2              0.000005     let suffix = get(self.fields, 'signature', '')
    2              0.000004     if has_key(self.fields, 'type')
                                    let suffix .= ' : ' . self.fields.type
    2              0.000011     elseif has_key(get(typeinfo, 'kind2scope', {}), self.fields.kind)
    2   0.000039   0.000021         let scope = s:maybe_map_scope(typeinfo.kind2scope[self.fields.kind])
    2              0.000002         if !g:tagbar_show_data_type
    2              0.000005             let suffix .= ' : ' . scope
    2              0.000001         endif
    2              0.000001     endif
    2   0.000077   0.000016     let prefix = self._getPrefix()
                            
    2              0.000022     if g:tagbar_show_data_type && self.getDataType() !=# ''
                                    let suffix .= ' : ' . self.getDataType()
    2              0.000001     endif
                            
    2              0.000004     if g:tagbar_show_tag_linenumbers == 1
                                    let suffix .= ' [' . self.fields.line . ']'
    2              0.000004     elseif g:tagbar_show_tag_linenumbers == 2
                                    let prefix .= '[' . self.fields.line . '] '
    2              0.000001     endif
                            
    2              0.000007     return prefix . self.name . suffix

FUNCTION  gitstatus#util#ParseGitStatusLines()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 82
Called 7 times
Total time:   0.004412
 Self time:   0.001494

count  total (s)   self (s)
    7              0.000012     let l:result = {}
    7              0.000008     let l:is_rename = 0
   49              0.000053     for l:line in a:statusLines
   42              0.000029         if l:is_rename
                                        call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, a:root . '/' . l:line, 'Dirty', a:opts)
                                        let l:is_rename = 0
                                        continue
   42              0.000016         endif
   42   0.001974   0.000353         let [l:pathStr, l:statusKey] = gitstatus#util#ParseGitStatusLine(l:line, a:opts)
                            
   42              0.000088         let l:pathStr = a:root . '/' . l:pathStr
   42              0.000060         if l:pathStr[-1:-1] is# '/'
    7              0.000009             let l:pathStr = l:pathStr[:-2]
   42              0.000015         endif
   42              0.000061         let l:is_rename = l:statusKey is# 'Renamed'
   42              0.000092         let l:result[l:pathStr] = l:statusKey
                            
   42   0.001628   0.000330         call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, l:pathStr, l:statusKey, a:opts)
   49              0.000026     endfor
    7              0.000005     return l:result

FUNCTION  <SNR>132_highlight_name_for_change()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 234
Called 44 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
   44              0.000038   if a:text ==# 'added'
   27              0.000016     return 'GitGutterLineAdded'
   17              0.000014   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
   17              0.000015   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   17              0.000013   elseif a:text ==# 'modified'
   17              0.000011     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>130_process_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 240
Called 24 times
Total time:   0.002531
 Self time:   0.001246

count  total (s)   self (s)
   24              0.000026   let modifications = []
   24              0.000029   let from_line  = a:hunk[0]
   24              0.000026   let from_count = a:hunk[1]
   24              0.000024   let to_line    = a:hunk[2]
   24              0.000024   let to_count   = a:hunk[3]
                            
   24   0.000136   0.000100   if s:is_added(from_count, to_count)
    7   0.000218   0.000038     call s:process_added(modifications, from_count, to_count, to_line)
    7   0.000280   0.000041     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   17   0.000097   0.000072   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
   17   0.000101   0.000067   elseif s:is_modified(from_count, to_count)
   17   0.000303   0.000097     call s:process_modified(modifications, from_count, to_count, to_line)
   17   0.000658   0.000095     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   24              0.000007   endif
   24              0.000018   return modifications

FUNCTION  <SNR>51_onFileUpdate()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 205
Called 2 times
Total time:   0.008653
 Self time:   0.000188

count  total (s)   self (s)
    2              0.000035     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
    2   0.000057   0.000037     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    2              0.000002     endif
    2   0.008245   0.000040     let l:job = s:refreshGitStatus('file-update', g:NTGitWorkdir)
    2   0.000304   0.000066     call s:logger.debug('run file-update job: ' . l:job.id)

FUNCTION  <SNR>123_getTags()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim line 80
Called 12 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
   12              0.000015     return self._taglist

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 5
Called 4 times
Total time:   0.000190
 Self time:   0.000049

count  total (s)   self (s)
    4   0.000101   0.000026   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.000086   0.000020   call s:reset_summary(a:bufnr)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 5890  11.165038   7.276062  162()
    5   4.270384   0.000286  <SNR>21_CursorHoldUpdate()
 6150   3.647458   0.049848  36()
 6150   3.357730   0.214351  265()
 6150   1.772124   0.469934  NERDTreeWebDevIconsRefreshListener()
 6150   1.265429   0.019715  278()
 6150   1.245715   0.085124  279()
  235   1.152906   0.677435  131()
 6150   1.147389   0.135354  280()
 6150   0.978637   0.576955  gitstatus#util#FormatPath()
12527   0.820311   0.421435  38()
 6150   0.750139   0.717418  WebDevIconsGetFileTypeSymbol()
    5   0.541974   0.000024  NERDTreeRender()
    5   0.541950   0.000021  nerdtree#renderView()
    5   0.541929   0.000022  233()
    5   0.541907   0.000860  254()
    5   0.539497   0.000033  130()
  130   0.506779   0.053851  150()
  105   0.505444   0.002043  152()
   75   0.489958   0.002175  138()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 5890  11.165038   7.276062  162()
 6150   0.750139   0.717418  WebDevIconsGetFileTypeSymbol()
  235   1.152906   0.677435  131()
 6150   0.978637   0.576955  gitstatus#util#FormatPath()
 6150   1.772124   0.469934  NERDTreeWebDevIconsRefreshListener()
12527   0.820311   0.421435  38()
    4   0.229763   0.223894  coc#float#create_cursor_float()
 6150   3.357730   0.214351  265()
 6465   0.447072   0.203855  26()
12522   0.367966   0.199516  43()
 6150   0.239880   0.167120  3()
 6150   1.147389   0.135354  280()
19080              0.127054  19()
 6465   0.139981   0.099605  27()
12522   0.133004   0.090088  nerdtree#slash()
 6150   1.245715   0.085124  279()
25044              0.078363  nerdtree#runningWindows()
12300              0.065257  <SNR>21_DevIconsGetArtifactFix()
    6   0.060228   0.058341  <SNR>77_HighlightTag()
12355              0.054452  209()

