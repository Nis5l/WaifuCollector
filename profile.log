SCRIPT  C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\syntax\javascript.vim
Sourced 3 times
Total time:   0.006132
 Self time:   0.006132

count  total (s)   self (s)
    3              0.000040 if has_key(g:polyglot_is_disabled, 'javascript')
                              finish
    3              0.000002 endif
                            
                            " Vim syntax file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    3              0.000007 if !exists("main_syntax")
    3              0.000004   if version < 600
                                syntax clear
    3              0.000006   elseif exists("b:current_syntax")
                                finish
    3              0.000002   endif
    3              0.000010   let main_syntax = 'javascript'
    3              0.000002 endif
                            
                            " Dollar sign is permitted anywhere in an identifier
    3              0.000010 if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
    3              0.000022   syntax iskeyword @,48-57,_,192-255,$
                            else
                              setlocal iskeyword+=$
    3              0.000001 endif
                            
    3              0.000006 syntax sync fromstart
                            " TODO: Figure out what type of casing I need
                            " syntax case ignore
    3              0.000002 syntax case match
                            
    3              0.000034 syntax match   jsNoise          /[:,;]/
    3              0.000043 syntax match   jsDot            /\./ skipwhite skipempty nextgroup=jsObjectProp,jsFuncCall,jsPrototype,jsTaggedTemplate
    3              0.000014 syntax match   jsObjectProp     contained /\<\K\k*/
    3              0.000014 syntax match   jsFuncCall       /\<\K\k*\ze\s*(/
    3              0.000012 syntax match   jsParensError    /[)}\]]/
                            
                            " Program Keywords
    3              0.000027 syntax keyword jsStorageClass   const var let skipwhite skipempty nextgroup=jsDestructuringBlock,jsDestructuringArray,jsVariableDef
    3              0.000016 syntax match   jsVariableDef    contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFlowDefinition
    3              0.000016 syntax keyword jsOperatorKeyword delete instanceof typeof void new in of skipwhite skipempty nextgroup=@jsExpression
    3              0.000015 syntax match   jsOperator       "[-!|&+<>=%/*~^]" skipwhite skipempty nextgroup=@jsExpression
    3              0.000011 syntax match   jsOperator       /::/ skipwhite skipempty nextgroup=@jsExpression
    3              0.000006 syntax keyword jsBooleanTrue    true
    3              0.000006 syntax keyword jsBooleanFalse   false
                            
                            " Modules
    3              0.000027 syntax keyword jsImport                       import skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup,jsFlowImportType
    3              0.000059 syntax keyword jsExport                       export skipwhite skipempty nextgroup=@jsAll,jsModuleGroup,jsExportDefault,jsModuleAsterisk,jsModuleKeyword,jsFlowTypeStatement
    3              0.000022 syntax match   jsModuleKeyword      contained /\<\K\k*/ skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    3              0.000015 syntax keyword jsExportDefault      contained default skipwhite skipempty nextgroup=@jsExpression
    3              0.000019 syntax keyword jsExportDefaultGroup contained default skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    3              0.000021 syntax match   jsModuleAsterisk     contained /\*/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAs,jsFrom
    3              0.000014 syntax keyword jsModuleAs           contained as skipwhite skipempty nextgroup=jsModuleKeyword,jsExportDefaultGroup
    3              0.000011 syntax keyword jsFrom               contained from skipwhite skipempty nextgroup=jsString
    3              0.000027 syntax match   jsModuleComma        contained /,/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAsterisk,jsModuleGroup,jsFlowTypeKeyword
                            
                            " Strings, Templates, Numbers
    3              0.000040 syntax region  jsString           start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+  contains=jsSpecial extend
    3              0.000026 syntax region  jsTemplateString   start=+`+  skip=+\\`+  end=+`+     contains=jsTemplateExpression,jsSpecial extend
    3              0.000016 syntax match   jsTaggedTemplate   /\<\K\k*\ze`/ nextgroup=jsTemplateString
    3              0.000023 syntax match   jsNumber           /\c\<\%(\d\+\%(e[+-]\=\d\+\)\=\|0b[01]\+\|0o\o\+\|0x\x\+\)\>/
    3              0.000007 syntax keyword jsNumber           Infinity
    3              0.000019 syntax match   jsFloat            /\c\<\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%(e[+-]\=\d\+\)\=\>/
                            
                            " Regular Expressions
    3              0.000020 syntax match   jsSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
    3              0.000027 syntax region  jsTemplateExpression contained matchgroup=jsTemplateBraces start=+${+ end=+}+ contains=@jsExpression keepend
    3              0.000020 syntax region  jsRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=jsSpecial extend
    3              0.000011 syntax match   jsRegexpBoundary     contained "\v\c[$^]|\\b"
    3              0.000010 syntax match   jsRegexpBackRef      contained "\v\\[1-9]\d*"
    3              0.000016 syntax match   jsRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
    3              0.000009 syntax match   jsRegexpOr           contained "|"
    3              0.000034 syntax match   jsRegexpMod          contained "\v\(\?[:=!>]"lc=1
    3              0.000035 syntax region  jsRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=jsRegexpCharClass,@jsRegexpSpecial keepend
    3              0.000081 syntax region  jsRegexpString   start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+ contains=jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial oneline keepend extend
    3              0.000029 syntax cluster jsRegexpSpecial    contains=jsSpecial,jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
                            
                            " Objects
    3              0.000017 syntax match   jsObjectShorthandProp contained /\<\k*\ze\s*/ skipwhite skipempty nextgroup=jsObjectSeparator
    3              0.000021 syntax match   jsObjectKey         contained /\<\k*\ze\s*:/ contains=jsFunctionKey skipwhite skipempty nextgroup=jsObjectValue
    3              0.000031 syntax region  jsObjectKeyString   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial skipwhite skipempty nextgroup=jsObjectValue
    3              0.000028 syntax region  jsObjectKeyComputed contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsObjectValue,jsFuncArgs extend
    3              0.000043 syntax match   jsObjectSeparator   contained /,/
    3              0.000034 syntax region  jsObjectValue       contained matchgroup=jsObjectColon start=/:/ end=/[,}]\@=/ contains=@jsExpression extend
    3              0.000016 syntax match   jsObjectFuncName    contained /\<\K\k*\ze\_s*(/ skipwhite skipempty nextgroup=jsFuncArgs
    3              0.000017 syntax match   jsFunctionKey       contained /\<\K\k*\ze\s*:\s*function\>/
    3              0.000018 syntax match   jsObjectMethodType  contained /\<[gs]et\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsObjectFuncName
    3              0.000032 syntax region  jsObjectStringKey   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs,jsObjectValue
                            
    3              0.000064 exe 'syntax keyword jsNull      null             '.(exists('g:javascript_conceal_null')      ? 'conceal cchar='.g:javascript_conceal_null       : '')
    3              0.000024 exe 'syntax keyword jsReturn    return contained '.(exists('g:javascript_conceal_return')    ? 'conceal cchar='.g:javascript_conceal_return     : '').' skipwhite nextgroup=@jsExpression'
    3              0.000038 exe 'syntax keyword jsUndefined undefined        '.(exists('g:javascript_conceal_undefined') ? 'conceal cchar='.g:javascript_conceal_undefined  : '')
    3              0.000035 exe 'syntax keyword jsNan       NaN              '.(exists('g:javascript_conceal_NaN')       ? 'conceal cchar='.g:javascript_conceal_NaN        : '')
    3              0.000017 exe 'syntax keyword jsPrototype prototype        '.(exists('g:javascript_conceal_prototype') ? 'conceal cchar='.g:javascript_conceal_prototype  : '')
    3              0.000016 exe 'syntax keyword jsThis      this             '.(exists('g:javascript_conceal_this')      ? 'conceal cchar='.g:javascript_conceal_this       : '')
    3              0.000014 exe 'syntax keyword jsSuper     super  contained '.(exists('g:javascript_conceal_super')     ? 'conceal cchar='.g:javascript_conceal_super      : '')
                            
                            " Statement Keywords
    3              0.000022 syntax match   jsBlockLabel              /\<\K\k*\s*::\@!/    contains=jsNoise skipwhite skipempty nextgroup=jsBlock
    3              0.000012 syntax match   jsBlockLabelKey contained /\<\K\k*\ze\s*\_[;]/
    3              0.000007 syntax keyword jsStatement     contained with yield debugger
    3              0.000011 syntax keyword jsStatement     contained break continue skipwhite skipempty nextgroup=jsBlockLabelKey
    3              0.000013 syntax keyword jsConditional            if              skipwhite skipempty nextgroup=jsParenIfElse
    3              0.000017 syntax keyword jsConditional            else            skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock
    3              0.000011 syntax keyword jsConditional            switch          skipwhite skipempty nextgroup=jsParenSwitch
    3              0.000016 syntax keyword jsRepeat                 while for       skipwhite skipempty nextgroup=jsParenRepeat,jsForAwait
    3              0.000013 syntax keyword jsDo                     do              skipwhite skipempty nextgroup=jsRepeatBlock
    3              0.000032 syntax region  jsSwitchCase   contained matchgroup=jsLabel start=/\<\%(case\|default\)\>/ end=/:\@=/ contains=@jsExpression,jsLabel skipwhite skipempty nextgroup=jsSwitchColon keepend
    3              0.000033 syntax keyword jsTry                    try             skipwhite skipempty nextgroup=jsTryCatchBlock
    3              0.000010 syntax keyword jsFinally      contained finally         skipwhite skipempty nextgroup=jsFinallyBlock
    3              0.000009 syntax keyword jsCatch        contained catch           skipwhite skipempty nextgroup=jsParenCatch
    3              0.000006 syntax keyword jsException              throw
    3              0.000008 syntax keyword jsAsyncKeyword           async await
    3              0.000013 syntax match   jsSwitchColon   contained /::\@!/        skipwhite skipempty nextgroup=jsSwitchBlock
                            
                            " Keywords
    3              0.000054 syntax keyword jsGlobalObjects     ArrayBuffer Array BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Boolean Buffer Collator DataView Date DateTimeFormat Function Intl Iterator JSON Map Set WeakMap WeakSet Math Number NumberFormat Object ParallelArray Promise Proxy Reflect RegExp String Symbol Uint8ClampedArray WebAssembly console document fetch window
    3              0.000015 syntax keyword jsGlobalNodeObjects  module exports global process __dirname __filename
    3              0.000045 syntax match   jsGlobalNodeObjects  /\<require\>/ containedin=jsFuncCall
    3              0.000013 syntax keyword jsExceptions         Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
    3              0.000013 syntax keyword jsBuiltins           decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
                            " DISCUSS: How imporant is this, really? Perhaps it should be linked to an error because I assume the keywords are reserved?
    3              0.000017 syntax keyword jsFutureKeys         abstract enum int short boolean interface byte long char final native synchronized float package throws goto private transient implements protected volatile double public
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 Objects
    3              0.000021 syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
    3              0.000007 syntax keyword jsExceptions     DOMException
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 CONSTANT
    3              0.000017 syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
    3              0.000071 syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                            
                            " DISCUSS: Should we really be special matching on these props?
                            " HTML events and internal variables
    3              0.000092 syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
                            
                            " Code blocks
    3              0.000027 syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold
    3              0.000036 syntax region  jsParen                        matchgroup=jsParens              start=/(/  end=/)/  contains=@jsExpression extend fold nextgroup=jsFlowDefinition
    3              0.000014 syntax region  jsParenDecorator     contained matchgroup=jsParensDecorator     start=/(/  end=/)/  contains=@jsAll extend fold
    3              0.000035 syntax region  jsParenIfElse        contained matchgroup=jsParensIfElse        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock,jsReturn extend fold
    3              0.000024 syntax region  jsParenRepeat        contained matchgroup=jsParensRepeat        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentRepeat,jsRepeatBlock,jsReturn extend fold
    3              0.000017 syntax region  jsParenSwitch        contained matchgroup=jsParensSwitch        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsSwitchBlock extend fold
    3              0.000035 syntax region  jsParenCatch         contained matchgroup=jsParensCatch         start=/(/  end=/)/  skipwhite skipempty nextgroup=jsTryCatchBlock extend fold
    3              0.000061 syntax region  jsFuncArgs           contained matchgroup=jsFuncParens          start=/(/  end=/)/  contains=jsFuncArgCommas,jsComment,jsFuncArgExpression,jsDestructuringBlock,jsDestructuringArray,jsRestExpression,jsFlowArgumentDef skipwhite skipempty nextgroup=jsCommentFunction,jsFuncBlock,jsFlowReturn extend fold
    3              0.000052 syntax region  jsClassBlock         contained matchgroup=jsClassBraces         start=/{/  end=/}/  contains=jsClassFuncName,jsClassMethodType,jsArrowFunction,jsArrowFuncArgs,jsComment,jsGenerator,jsDecorator,jsClassProperty,jsClassPropertyComputed,jsClassStringKey,jsAsyncKeyword,jsNoise extend fold
    3              0.000017 syntax region  jsFuncBlock          contained matchgroup=jsFuncBraces          start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    3              0.000016 syntax region  jsIfElseBlock        contained matchgroup=jsIfElseBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    3              0.000024 syntax region  jsTryCatchBlock      contained matchgroup=jsTryCatchBraces      start=/{/  end=/}/  contains=@jsAll,jsBlock skipwhite skipempty nextgroup=jsCatch,jsFinally extend fold
    3              0.000016 syntax region  jsFinallyBlock       contained matchgroup=jsFinallyBraces       start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    3              0.000019 syntax region  jsSwitchBlock        contained matchgroup=jsSwitchBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock,jsSwitchCase extend fold
    3              0.000018 syntax region  jsRepeatBlock        contained matchgroup=jsRepeatBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    3              0.000040 syntax region  jsDestructuringBlock contained matchgroup=jsDestructuringBraces start=/{/  end=/}/  contains=jsDestructuringProperty,jsDestructuringAssignment,jsDestructuringNoise,jsDestructuringPropertyComputed,jsSpreadExpression,jsComment nextgroup=jsFlowDefinition extend fold
    3              0.000046 syntax region  jsDestructuringArray contained matchgroup=jsDestructuringBraces start=/\[/ end=/\]/ contains=jsDestructuringPropertyValue,jsDestructuringNoise,jsDestructuringProperty,jsSpreadExpression,jsDestructuringBlock,jsDestructuringArray,jsComment nextgroup=jsFlowDefinition extend fold
    3              0.000066 syntax region  jsObject             contained matchgroup=jsObjectBraces        start=/{/  end=/}/  contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectShorthandProp,jsObjectSeparator,jsObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsDecorator,jsAsyncKeyword,jsTemplateString extend fold
    3              0.000021 syntax region  jsBlock                        matchgroup=jsBraces              start=/{/  end=/}/  contains=@jsAll,jsSpreadExpression extend fold
    3              0.000042 syntax region  jsModuleGroup        contained matchgroup=jsModuleBraces        start=/{/ end=/}/   contains=jsModuleKeyword,jsModuleComma,jsModuleAs,jsComment,jsFlowTypeKeyword skipwhite skipempty nextgroup=jsFrom fold
    3              0.000019 syntax region  jsSpreadExpression   contained matchgroup=jsSpreadOperator      start=/\.\.\./ end=/[,}\]]\@=/ contains=@jsExpression
    3              0.000015 syntax region  jsRestExpression     contained matchgroup=jsRestOperator        start=/\.\.\./ end=/[,)]\@=/
    3              0.000022 syntax region  jsTernaryIf                    matchgroup=jsTernaryIfOperator   start=/?:\@!/  end=/\%(:\|}\@=\)/  contains=@jsExpression extend skipwhite skipempty nextgroup=@jsExpression
                            " These must occur here or they will be override by jsTernaryIf
    3              0.000013 syntax match   jsOperator           /?\.\ze\_D/
    3              0.000012 syntax match   jsOperator           /??/ skipwhite skipempty nextgroup=@jsExpression
                            
    3              0.000020 syntax match   jsGenerator            contained /\*/ skipwhite skipempty nextgroup=jsFuncName,jsFuncArgs,jsFlowFunctionGroup
    3              0.000017 syntax match   jsFuncName             contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowFunctionGroup
    3              0.000016 syntax region  jsFuncArgExpression    contained matchgroup=jsFuncArgOperator start=/=/ end=/[,)]\@=/ contains=@jsExpression extend
    3              0.000006 syntax match   jsFuncArgCommas        contained ','
    3              0.000013 syntax keyword jsArguments            contained arguments
    3              0.000010 syntax keyword jsForAwait             contained await skipwhite skipempty nextgroup=jsParenRepeat
                            
                            " Matches a single keyword argument with no parens
    3              0.000047 syntax match   jsArrowFuncArgs  /\<\K\k*\ze\s*=>/ skipwhite contains=jsFuncArgs skipwhite skipempty nextgroup=jsArrowFunction extend
                            " Matches a series of arguments surrounded in parens
    3              0.000033 syntax match   jsArrowFuncArgs  /([^()]*)\ze\s*=>/ contains=jsFuncArgs skipempty skipwhite nextgroup=jsArrowFunction extend
                            
    3              0.000066 exe 'syntax match jsFunction /\<function\>/      skipwhite skipempty nextgroup=jsGenerator,jsFuncName,jsFuncArgs,jsFlowFunctionGroup skipwhite '.(exists('g:javascript_conceal_function') ? 'conceal cchar='.g:javascript_conceal_function : '')
    3              0.000033 exe 'syntax match jsArrowFunction /=>/           skipwhite skipempty nextgroup=jsFuncBlock,jsCommentFunction '.(exists('g:javascript_conceal_arrow_function') ? 'conceal cchar='.g:javascript_conceal_arrow_function : '')
    3              0.000029 exe 'syntax match jsArrowFunction /()\ze\s*=>/   skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_noarg_arrow_function') ? 'conceal cchar='.g:javascript_conceal_noarg_arrow_function : '')
    3              0.000025 exe 'syntax match jsArrowFunction /_\ze\s*=>/    skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_underscore_arrow_function') ? 'conceal cchar='.g:javascript_conceal_underscore_arrow_function : '')
                            
                            " Classes
    3              0.000020 syntax keyword jsClassKeyword           contained class
    3              0.000021 syntax keyword jsExtendsKeyword         contained extends skipwhite skipempty nextgroup=@jsExpression
    3              0.000008 syntax match   jsClassNoise             contained /\./
    3              0.000019 syntax match   jsClassFuncName          contained /\<\K\k*\ze\s*[(<]/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowClassFunctionGroup
    3              0.000026 syntax match   jsClassMethodType        contained /\<\%([gs]et\|static\)\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsAsyncKeyword,jsClassFuncName,jsClassProperty
    3              0.000067 syntax region  jsClassDefinition                  start=/\<class\>/ end=/\(\<extends\>\s\+\)\@<!{\@=/ contains=jsClassKeyword,jsExtendsKeyword,jsClassNoise,@jsExpression,jsFlowClassGroup skipwhite skipempty nextgroup=jsCommentClass,jsClassBlock,jsFlowClassGroup
    3              0.000016 syntax match   jsClassProperty          contained /\<\K\k*\ze\s*[=;]/ skipwhite skipempty nextgroup=jsClassValue,jsFlowClassDef
    3              0.000015 syntax region  jsClassValue             contained start=/=/ end=/\_[;}]\@=/ contains=@jsExpression
    3              0.000023 syntax region  jsClassPropertyComputed  contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsFuncArgs,jsClassValue extend
    3              0.000027 syntax region  jsClassStringKey         contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs
                            
                            " Destructuring
    3              0.000008 syntax match   jsDestructuringPropertyValue     contained /\k\+/
    3              0.000012 syntax match   jsDestructuringProperty          contained /\k\+\ze\s*=/ skipwhite skipempty nextgroup=jsDestructuringValue
    3              0.000011 syntax match   jsDestructuringAssignment        contained /\k\+\ze\s*:/ skipwhite skipempty nextgroup=jsDestructuringValueAssignment
    3              0.000014 syntax region  jsDestructuringValue             contained start=/=/ end=/[,}\]]\@=/ contains=@jsExpression extend
    3              0.000031 syntax region  jsDestructuringValueAssignment   contained start=/:/ end=/[,}=]\@=/ contains=jsDestructuringPropertyValue,jsDestructuringBlock,jsNoise,jsDestructuringNoise skipwhite skipempty nextgroup=jsDestructuringValue extend
    3              0.000010 syntax match   jsDestructuringNoise             contained /[,[\]]/
    3              0.000022 syntax region  jsDestructuringPropertyComputed  contained matchgroup=jsDestructuringBraces start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsDestructuringValue,jsDestructuringValueAssignment,jsDestructuringNoise extend fold
                            
                            " Comments
    3              0.000041 syntax keyword jsCommentTodo    contained TODO FIXME XXX TBD NOTE
    3              0.000021 syntax region  jsComment        start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
    3              0.000019 syntax region  jsComment        start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell fold extend keepend
    3              0.000015 syntax region  jsEnvComment     start=/\%^#!/ end=/$/ display
                            
                            " Specialized Comments - These are special comment regexes that are used in
                            " odd places that maintain the proper nextgroup functionality. It sucks we
                            " can't make jsComment a skippable type of group for nextgroup
    3              0.000025 syntax region  jsCommentFunction    contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn extend keepend
    3              0.000022 syntax region  jsCommentFunction    contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn fold extend keepend
    3              0.000020 syntax region  jsCommentClass       contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup extend keepend
    3              0.000020 syntax region  jsCommentClass       contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup fold extend keepend
    3              0.000019 syntax region  jsCommentIfElse      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock extend keepend
    3              0.000019 syntax region  jsCommentIfElse      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock fold extend keepend
    3              0.000018 syntax region  jsCommentRepeat      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock extend keepend
    3              0.000017 syntax region  jsCommentRepeat      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock fold extend keepend
                            
                            " Decorators
    3              0.000014 syntax match   jsDecorator                    /^\s*@/ nextgroup=jsDecoratorFunction
    3              0.000012 syntax match   jsDecoratorFunction  contained /\h[a-zA-Z0-9_.]*/ nextgroup=jsParenDecorator
                            
    3              0.000007 if exists("javascript_plugin_jsdoc")
                              runtime extras/jsdoc.vim
                              " NGDoc requires JSDoc
                              if exists("javascript_plugin_ngdoc")
                                runtime extras/ngdoc.vim
                              endif
    3              0.000001 endif
                            
    3              0.000006 if exists("javascript_plugin_flow")
                              runtime extras/flow.vim
    3              0.000001 endif
                            
    3              0.000277 syntax cluster jsExpression  contains=jsBracket,jsParen,jsObject,jsTernaryIf,jsTaggedTemplate,jsTemplateString,jsString,jsRegexpString,jsNumber,jsFloat,jsOperator,jsOperatorKeyword,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsArrowFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsFuncCall,jsUndefined,jsNan,jsPrototype,jsBuiltins,jsNoise,jsClassDefinition,jsArrowFunction,jsArrowFuncArgs,jsParensError,jsComment,jsArguments,jsThis,jsSuper,jsDo,jsForAwait,jsAsyncKeyword,jsStatement,jsDot
    3              0.000037 syntax cluster jsAll         contains=@jsExpression,jsStorageClass,jsConditional,jsRepeat,jsReturn,jsException,jsTry,jsNoise,jsBlockLabel
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000006 if version >= 508 || !exists("did_javascript_syn_inits")
    3              0.000003   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
    3              0.000002   else
    3              0.000027     command -nargs=+ HiLink hi def link <args>
    3              0.000002   endif
    3              0.000032   HiLink jsComment              Comment
    3              0.000017   HiLink jsEnvComment           PreProc
    3              0.000014   HiLink jsParensIfElse         jsParens
    3              0.000013   HiLink jsParensRepeat         jsParens
    3              0.000012   HiLink jsParensSwitch         jsParens
    3              0.000012   HiLink jsParensCatch          jsParens
    3              0.000013   HiLink jsCommentTodo          Todo
    3              0.000019   HiLink jsString               String
    3              0.000016   HiLink jsObjectKeyString      String
    3              0.000016   HiLink jsTemplateString       String
    3              0.000015   HiLink jsObjectStringKey      String
    3              0.000015   HiLink jsClassStringKey       String
    3              0.000016   HiLink jsTaggedTemplate       StorageClass
    3              0.000021   HiLink jsTernaryIfOperator    Operator
    3              0.000015   HiLink jsRegexpString         String
    3              0.000016   HiLink jsRegexpBoundary       SpecialChar
    3              0.000016   HiLink jsRegexpQuantifier     SpecialChar
    3              0.000016   HiLink jsRegexpOr             Conditional
    3              0.000015   HiLink jsRegexpMod            SpecialChar
    3              0.000015   HiLink jsRegexpBackRef        SpecialChar
    3              0.000010   HiLink jsRegexpGroup          jsRegexpString
    3              0.000015   HiLink jsRegexpCharClass      Character
    3              0.000014   HiLink jsCharacter            Character
    3              0.000015   HiLink jsPrototype            Special
    3              0.000016   HiLink jsConditional          Conditional
    3              0.000016   HiLink jsBranch               Conditional
    3              0.000015   HiLink jsLabel                Label
    3              0.000015   HiLink jsReturn               Statement
    3              0.000014   HiLink jsRepeat               Repeat
    3              0.000031   HiLink jsDo                   Repeat
    3              0.000039   HiLink jsStatement            Statement
    3              0.000014   HiLink jsException            Exception
    3              0.000014   HiLink jsTry                  Exception
    3              0.000014   HiLink jsFinally              Exception
    3              0.000028   HiLink jsCatch                Exception
    3              0.000014   HiLink jsAsyncKeyword         Keyword
    3              0.000014   HiLink jsForAwait             Keyword
    3              0.000015   HiLink jsArrowFunction        Type
    3              0.000020   HiLink jsFunction             Type
    3              0.000014   HiLink jsGenerator            jsFunction
    3              0.000009   HiLink jsArrowFuncArgs        jsFuncArgs
    3              0.000012   HiLink jsFuncName             Function
    3              0.000014   HiLink jsFuncCall             Function
    3              0.000008   HiLink jsClassFuncName        jsFuncName
    3              0.000013   HiLink jsObjectFuncName       Function
    3              0.000014   HiLink jsArguments            Special
    3              0.000014   HiLink jsError                Error
    3              0.000015   HiLink jsParensError          Error
    3              0.000010   HiLink jsOperatorKeyword      jsOperator
    3              0.000015   HiLink jsOperator             Operator
    3              0.000015   HiLink jsOf                   Operator
    3              0.000016   HiLink jsStorageClass         StorageClass
    3              0.000018   HiLink jsClassKeyword         Keyword
    3              0.000018   HiLink jsExtendsKeyword       Keyword
    3              0.000014   HiLink jsThis                 Special
    3              0.000015   HiLink jsSuper                Constant
    3              0.000020   HiLink jsNan                  Number
    3              0.000019   HiLink jsNull                 Type
    3              0.000018   HiLink jsUndefined            Type
    3              0.000016   HiLink jsNumber               Number
    3              0.000015   HiLink jsFloat                Float
    3              0.000015   HiLink jsBooleanTrue          Boolean
    3              0.000014   HiLink jsBooleanFalse         Boolean
    3              0.000009   HiLink jsObjectColon          jsNoise
    3              0.000007   HiLink jsNoise                Noise
    3              0.000008   HiLink jsDot                  Noise
    3              0.000007   HiLink jsBrackets             Noise
    3              0.000012   HiLink jsParens               Noise
    3              0.000006   HiLink jsBraces               Noise
    3              0.000006   HiLink jsFuncBraces           Noise
    3              0.000011   HiLink jsFuncParens           Noise
    3              0.000007   HiLink jsClassBraces          Noise
    3              0.000008   HiLink jsClassNoise           Noise
    3              0.000006   HiLink jsIfElseBraces         Noise
    3              0.000006   HiLink jsTryCatchBraces       Noise
    3              0.000006   HiLink jsModuleBraces         Noise
    3              0.000006   HiLink jsObjectBraces         Noise
    3              0.000007   HiLink jsObjectSeparator      Noise
    3              0.000006   HiLink jsFinallyBraces        Noise
    3              0.000006   HiLink jsRepeatBraces         Noise
    3              0.000006   HiLink jsSwitchBraces         Noise
    3              0.000014   HiLink jsSpecial              Special
    3              0.000013   HiLink jsTemplateBraces       Noise
    3              0.000018   HiLink jsGlobalObjects        Constant
    3              0.000018   HiLink jsGlobalNodeObjects    Constant
    3              0.000015   HiLink jsExceptions           Constant
    3              0.000014   HiLink jsBuiltins             Constant
    3              0.000014   HiLink jsImport               Include
    3              0.000014   HiLink jsExport               Include
    3              0.000018   HiLink jsExportDefault        StorageClass
    3              0.000014   HiLink jsExportDefaultGroup   jsExportDefault
    3              0.000013   HiLink jsModuleAs             Include
    3              0.000009   HiLink jsModuleComma          jsNoise
    3              0.000007   HiLink jsModuleAsterisk       Noise
    3              0.000013   HiLink jsFrom                 Include
    3              0.000014   HiLink jsDecorator            Special
    3              0.000013   HiLink jsDecoratorFunction    Function
    3              0.000013   HiLink jsParensDecorator      jsParens
    3              0.000009   HiLink jsFuncArgOperator      jsFuncArgs
    3              0.000008   HiLink jsClassProperty        jsObjectKey
    3              0.000009   HiLink jsObjectShorthandProp  jsObjectKey
    3              0.000013   HiLink jsSpreadOperator       Operator
    3              0.000015   HiLink jsRestOperator         Operator
    3              0.000009   HiLink jsRestExpression       jsFuncArgs
    3              0.000007   HiLink jsSwitchColon          Noise
    3              0.000014   HiLink jsClassMethodType      Type
    3              0.000015   HiLink jsObjectMethodType     Type
    3              0.000014   HiLink jsClassDefinition      jsFuncName
    3              0.000014   HiLink jsBlockLabel           Identifier
    3              0.000009   HiLink jsBlockLabelKey        jsBlockLabel
                            
    3              0.000007   HiLink jsDestructuringBraces     Noise
    3              0.000008   HiLink jsDestructuringProperty   jsFuncArgs
    3              0.000008   HiLink jsDestructuringAssignment jsObjectKey
    3              0.000006   HiLink jsDestructuringNoise      Noise
                            
    3              0.000008   HiLink jsCommentFunction      jsComment
    3              0.000007   HiLink jsCommentClass         jsComment
    3              0.000007   HiLink jsCommentIfElse        jsComment
    3              0.000006   HiLink jsCommentRepeat        jsComment
                            
    3              0.000015   HiLink jsDomErrNo             Constant
    3              0.000015   HiLink jsDomNodeConsts        Constant
    3              0.000013   HiLink jsDomElemAttrs         Label
    3              0.000013   HiLink jsDomElemFuncs         PreProc
                            
    3              0.000014   HiLink jsHtmlEvents           Special
    3              0.000013   HiLink jsHtmlElemAttrs        Label
    3              0.000013   HiLink jsHtmlElemFuncs        PreProc
                            
    3              0.000013   HiLink jsCssStyles            Label
                            
    3              0.000004   delcommand HiLink
    3              0.000002 endif
                            
                            " Define the htmlJavaScript for HTML syntax html.vim
    3              0.000017 syntax cluster  htmlJavaScript       contains=@jsAll,jsImport,jsExport
    3              0.000005 syntax cluster  javaScriptExpression contains=@jsAll
                            
                            " Vim's default html.vim highlights all javascript as 'Special'
    3              0.000005 hi! def link javaScript              NONE
                            
    3              0.000007 let b:current_syntax = "javascript"
    3              0.000005 if main_syntax == 'javascript'
    3              0.000008   unlet main_syntax
    3              0.000010 endif

SCRIPT  C:\Program Files\Neovim\share\nvim\runtime\syntax\javascript.vim
Sourced 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2018 Jul 28
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    3              0.000011 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
    3              0.000006   if exists("b:current_syntax")
    3              0.000003     finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            
                            syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
                            syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
                            syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
                            syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
                            syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            syn match   javaScriptSpecialCharacter "'\\.'"
                            syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
                            syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
                            syn keyword javaScriptConditional	if else switch
                            syn keyword javaScriptRepeat		while for do in
                            syn keyword javaScriptBranch		break continue
                            syn keyword javaScriptOperator		new delete instanceof typeof
                            syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
                            syn keyword javaScriptStatement		return with
                            syn keyword javaScriptBoolean		true false
                            syn keyword javaScriptNull		null undefined
                            syn keyword javaScriptIdentifier	arguments this var let
                            syn keyword javaScriptLabel		case default
                            syn keyword javaScriptException		try catch finally throw
                            syn keyword javaScriptMessage		alert confirm prompt status
                            syn keyword javaScriptGlobal		self window top parent
                            syn keyword javaScriptMember		document event location 
                            syn keyword javaScriptDeprecated	escape unescape
                            syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
                            syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
                            if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
                                syn keyword javaScriptFunction	function
                                syn match	javaScriptBraces	   "[{}\[\]]"
                                syn match	javaScriptParens	   "[()]"
                            endif
                            
                            syn sync fromstart
                            syn sync maxlines=100
                            
                            if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            hi def link javaScriptComment		Comment
                            hi def link javaScriptLineComment		Comment
                            hi def link javaScriptCommentTodo		Todo
                            hi def link javaScriptSpecial		Special
                            hi def link javaScriptStringS		String
                            hi def link javaScriptStringD		String
                            hi def link javaScriptStringT		String
                            hi def link javaScriptCharacter		Character
                            hi def link javaScriptSpecialCharacter	javaScriptSpecial
                            hi def link javaScriptNumber		javaScriptValue
                            hi def link javaScriptConditional		Conditional
                            hi def link javaScriptRepeat		Repeat
                            hi def link javaScriptBranch		Conditional
                            hi def link javaScriptOperator		Operator
                            hi def link javaScriptType			Type
                            hi def link javaScriptStatement		Statement
                            hi def link javaScriptFunction		Function
                            hi def link javaScriptBraces		Function
                            hi def link javaScriptError		Error
                            hi def link javaScrParenError		javaScriptError
                            hi def link javaScriptNull			Keyword
                            hi def link javaScriptBoolean		Boolean
                            hi def link javaScriptRegexpString		String
                            
                            hi def link javaScriptIdentifier		Identifier
                            hi def link javaScriptLabel		Label
                            hi def link javaScriptException		Exception
                            hi def link javaScriptMessage		Keyword
                            hi def link javaScriptGlobal		Keyword
                            hi def link javaScriptMember		Keyword
                            hi def link javaScriptDeprecated		Exception 
                            hi def link javaScriptReserved		Keyword
                            hi def link javaScriptDebug		Debug
                            hi def link javaScriptConstant		Label
                            hi def link javaScriptEmbed		Special
                            
                            
                            
                            let b:current_syntax = "javascript"
                            if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\after\syntax\javascript.vim
Sourced 3 times
Total time:   0.006115
 Self time:   0.000724

count  total (s)   self (s)
    3              0.000015 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    3              0.000002 endif
                            
    3              0.000035 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    3              0.000001 endif
                            
    3   0.005985   0.000594 source <sfile>:h/jsx.vim

SCRIPT  C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\after\syntax\jsx.vim
Sourced 3 times
Total time:   0.005256
 Self time:   0.004021

count  total (s)   self (s)
    3              0.000013 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    3              0.000001 endif
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    3              0.000016 let s:jsx_cpo = &cpo
    3   0.000025   0.000019 set cpo&vim
                            
    3              0.000003 syntax case match
                            
    3              0.000007 if exists('b:current_syntax')
    3              0.000005   let s:current_syntax = b:current_syntax
    3              0.000004   unlet b:current_syntax
    3              0.000001 endif
                            
    3              0.000005 if exists('s:current_syntax')
    3              0.000005   let b:current_syntax = s:current_syntax
    3              0.000001 endif
                            
    3              0.000031 if hlexists("jsDebugger") || hlexists("jsNoise")    " yuezk/vim-js or pangloss/vim-javascript
    3              0.000020   syntax cluster jsExpression add=jsxRegion
                            elseif hlexists("javascriptOpSymbols")    " othree/yajs.vim
                              " refine the javascript line comment
                              syntax region javascriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                              syntax cluster javascriptValue add=jsxRegion
                              syntax cluster javascriptNoReserved add=jsxElement,jsxTag
                            else    " build-in javascript syntax
                              " refine the javascript line comment
                              syntax region javaScriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                            
                              " refine the template string syntax
                              syntax region javaScriptEmbed matchgroup=javaScriptEmbedBraces start=+\${+ end=+}+ contained contains=@javaScriptEmbededExpr
                            
                              " add a javaScriptBlock group for build-in syntax
                              syntax region javaScriptBlock
                                    \ matchgroup=javaScriptBraces
                                    \ start="{"
                                    \ end="}"
                                    \ contained
                                    \ extend
                                    \ contains=javaScriptBlock,@javaScriptEmbededExpr,javaScript.*
                                    \ fold
                            
                              syntax cluster javaScriptEmbededExpr add=jsxRegion,javaScript.*
    3              0.000002 endif
                            
    3   0.003485   0.002261 runtime syntax/jsx_pretty.vim
                            
    3              0.000006 let b:current_syntax = 'javascript.jsx'
                            
    3   0.000028   0.000022 let &cpo = s:jsx_cpo
    3              0.000014 unlet s:jsx_cpo

SCRIPT  C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\after\syntax\jsx_pretty.vim
Sourced 3 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
    3              0.000016 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    3              0.000002 endif
                            
    3              0.000011 let s:highlight_close_tag = get(g:, 'vim_jsx_pretty_highlight_close_tag', 0)
                            
                            " detect jsx region
    3              0.000083 syntax region jsxRegion
                                  \ start=+\%(\%(\_[([,?:=+\-*/>{}]\|<\s\+\|&&\|||\|=>\|\<return\|\<default\|\<await\|\<yield\)\_s*\)\@<=<\_s*\%(>\|\z(\%(script\|\s*\<T\>\)\@!\<[_$A-Za-z][-:._$A-Za-z0-9]*\>\)\%(\_s*\%([-+*)\]}&|?,]\|/\%([/*]\|\_s*>\)\@!\)\)\@!\)+
                                  \ end=++
                                  \ contains=jsxElement
                            
                            " <tag id="sample">
                            " ~~~~~~~~~~~~~~~~~
                            " and self close tag
                            " <tag id="sample"   />
                            " ~~~~~~~~~~~~~~~~~~~
    3              0.000072 syntax region jsxTag
                                  \ start=+<+
                                  \ matchgroup=jsxOpenPunct
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\%(/\_s*>\)\@=+
                                  \ contained
                                  \ contains=jsxOpenTag,jsxAttrib,jsxExpressionBlock,jsxSpreadOperator,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                                  \ keepend
                                  \ extend
                                  \ skipwhite
                                  \ skipempty
                                  \ nextgroup=jsxCloseString
                            
                            " <tag></tag>
                            " ~~~~~~~~~~~
                            " and fragment
                            " <></>
                            " ~~~~~
                            " and self close tag
                            " <tag />
                            " ~~~~~~~
    3              0.000056 syntax region jsxElement
                                  \ start=+<\_s*\%(>\|\${\|\z(\<[-:._$A-Za-z0-9]\+\>\)\)+
                                  \ end=+/\_s*>+
                                  \ end=+<\_s*/\_s*\z1\_s*>+
                                  \ contains=jsxElement,jsxTag,jsxExpressionBlock,jsxComment,jsxCloseTag,@Spell
                                  \ keepend
                                  \ extend
                                  \ contained
                                  \ fold
                            
                            " <tag key={this.props.key}>
                            " ~~~~
                            " and fragment start tag
                            " <>
                            " ~~
    3              0.000044 exe 'syntax region jsxOpenTag
                                  \ matchgroup=jsxOpenPunct
                                  \ start=+<+
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\>+
                                  \ contained
                                  \ contains=jsxTagName
                                  \ nextgroup=jsxAttrib
                                  \ skipwhite
                                  \ skipempty
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            
                            " <tag key={this.props.key}>
                            "          ~~~~~~~~~~~~~~~~
    3              0.000058 syntax region jsxExpressionBlock
                                  \ matchgroup=jsxBraces
                                  \ start=+{+
                                  \ end=+}+
                                  \ contained
                                  \ extend
                                  \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                            
                            " <foo.bar>
                            "     ~
    3              0.000008 syntax match jsxDot +\.+ contained
                            
                            " <foo:bar>
                            "     ~
    3              0.000006 syntax match jsxNamespace +:+ contained
                            
                            " <tag id="sample">
                            "        ~
    3              0.000012 syntax match jsxEqual +=+ contained skipwhite skipempty nextgroup=jsxString,jsxExpressionBlock,jsxRegion
                            
                            " <tag />
                            "      ~~
    3              0.000007 syntax match jsxCloseString +/\_s*>+ contained
                            
                            " </tag>
                            " ~~~~~~
                            " and fragment close tag
                            " </>
                            " ~~~
    3              0.000018 syntax region jsxCloseTag
                                  \ matchgroup=jsxClosePunct
                                  \ start=+<\_s*/+
                                  \ end=+>+
                                  \ contained
                                  \ contains=jsxTagName
                            
                            " <tag key={this.props.key}>
                            "      ~~~
    3              0.000025 syntax match jsxAttrib
                                  \ +\<[_$A-Za-z][-:_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ nextgroup=jsxEqual
                                  \ skipwhite
                                  \ skipempty
                                  \ contains=jsxAttribKeyword,jsxNamespace
                            
                            " <MyComponent ...>
                            "  ~~~~~~~~~~~
                            " NOT
                            " <someCamel ...>
                            "      ~~~~~
    3              0.000024 exe 'syntax match jsxComponentName
                                  \ +\<[_$]\?[A-Z][-_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag key={this.props.key}>
                            "  ~~~
    3              0.000040 exe 'syntax match jsxTagName
                                  \ +\<[-:._$A-Za-z0-9]\+\>+
                                  \ contained
                                  \ contains=jsxComponentName,jsxDot,jsxNamespace
                                  \ nextgroup=jsxAttrib
                                  \ skipempty
                                  \ skipwhite
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag id="sample">
                            "         ~~~~~~~~
                            " and
                            " <tag id='sample'>
                            "         ~~~~~~~~
    3              0.000024 syntax region jsxString start=+\z(["']\)+  skip=+\\\\\|\\\z1\|\\\n+  end=+\z1+ extend contained contains=@Spell
                            
    3              0.000015 let s:tags = get(g:, 'vim_jsx_pretty_template_tags', ['html', 'jsx'])
    3              0.000007 let s:enable_tagged_jsx = !empty(s:tags)
                            
                            " add support to JSX inside the tagged template string
                            " https://github.com/developit/htm
    3              0.000023 if s:enable_tagged_jsx
    3              0.000050   exe 'syntax match jsxRegion +\%(' . join(s:tags, '\|') . '\)\%(\_s*`\)\@=+ contains=jsTemplateStringTag,jsTaggedTemplate,javascriptTagRef skipwhite skipempty nextgroup=jsxTaggedRegion'
                            
    3              0.000024   syntax region jsxTaggedRegion
                                    \ matchgroup=jsxBackticks
                                    \ start=+`+
                                    \ end=+`+
                                    \ extend
                                    \ contained
                                    \ contains=jsxElement,jsxExpressionBlock
                                    \ transparent
                            
    3              0.000035   syntax region jsxExpressionBlock
                                    \ matchgroup=jsxBraces
                                    \ start=+\${+
                                    \ end=+}+
                                    \ extend
                                    \ contained
                                    \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread
                            
    3              0.000030   syntax region jsxOpenTag
                                    \ matchgroup=jsxOpenPunct
                                    \ start=+<\%(\${\)\@=+
                                    \ matchgroup=NONE
                                    \ end=+}\@1<=+
                                    \ contained
                                    \ contains=jsxExpressionBlock
                                    \ skipwhite
                                    \ skipempty
                                    \ nextgroup=jsxAttrib,jsxSpreadOperator
                            
    3              0.000006   syntax keyword jsxAttribKeyword class contained
                            
    3              0.000009   syntax match jsxSpreadOperator +\.\.\.+ contained nextgroup=jsxExpressionBlock skipwhite
                            
    3              0.000007   syntax match jsxCloseTag +<//>+ contained
                            
    3              0.000015   syntax match jsxComment +<!--\_.\{-}-->+
    3              0.000002 endif
                            
                            " Highlight the tag name
    3              0.000019 highlight def link jsxTag Function
    3              0.000013 highlight def link jsxTagName Identifier
    3              0.000010 highlight def link jsxComponentName Function
                            
    3              0.000011 highlight def link jsxAttrib Type
    3              0.000004 highlight def link jsxAttribKeyword jsxAttrib
    3              0.000011 highlight def link jsxString String
    3              0.000011 highlight def link jsxComment Comment
                            
    3              0.000011 highlight def link jsxDot Operator
    3              0.000011 highlight def link jsxNamespace Operator
    3              0.000011 highlight def link jsxEqual Operator
    3              0.000011 highlight def link jsxSpreadOperator Operator
    3              0.000011 highlight def link jsxBraces Special
                            
    3              0.000004 if s:highlight_close_tag
                              highlight def link jsxCloseString Identifier
                              highlight def link jsxOpenPunct jsxTag
    3              0.000003 else
                              " Highlight the jsxCloseString (i.e. />), jsxPunct (i.e. <,>) and jsxCloseTag (i.e. <//>)
    3              0.000013   highlight def link jsxCloseString Comment
    3              0.000004   highlight def link jsxOpenPunct jsxPunct
    3              0.000002 endif
                            
    3              0.000004 highlight def link jsxPunct jsxCloseString
    3              0.000004 highlight def link jsxClosePunct jsxPunct
    3              0.000003 highlight def link jsxCloseTag jsxCloseString
                            
    3              0.000010 let s:vim_jsx_pretty_colorful_config = get(g:, 'vim_jsx_pretty_colorful_config', 0)
                            
    3              0.000004 if s:vim_jsx_pretty_colorful_config == 1
                              highlight def link jsObjectKey Label
                              highlight def link jsArrowFuncArgs Type
                              highlight def link jsFuncArgs Type
    3              0.000013 endif

FUNCTION  <SNR>141_syntax_context()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 198
Called 4 times
Total time:   0.001309
 Self time:   0.000947

count  total (s)   self (s)
    4   0.000089   0.000050   let start_col = s:start_col(a:lnum)
    4   0.000177   0.000076   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
    4              0.000008   let start_syntax = syntax_stack[-1]
    4              0.000007   let reversed = reverse(syntax_stack)
    4              0.000003   let i = 0
                            
   26              0.000023   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
   22   0.000181   0.000105     if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
   22              0.000007     endif
                            
   22   0.000154   0.000097     if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
   22              0.000006     endif
                            
   22   0.000224   0.000135     if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
   22              0.000006     endif
                            
   22              0.000019     let i = i + 1
   26              0.000033   endfor
                              
    4              0.000002   return 'Other'

FUNCTION  <SNR>26_notify()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 181
Called 111 times
Total time:   0.005309
 Self time:   0.004870

count  total (s)   self (s)
  111   0.001116   0.000678   let channel = coc#client#get_channel(self)
  111              0.000120   if empty(channel)
                                return ''
  111              0.000030   endif
  111              0.000057   try
  111              0.000064     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  111              0.000048     else
  111              0.001390       call call('rpcnotify', [channel, a:method] + a:args)
  111              0.000053     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  111              0.000059   endtry

FUNCTION  coc#client#get_channel()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 141
Called 119 times
Total time:   0.000470
 Self time:   0.000470

count  total (s)   self (s)
  119              0.000117   if s:is_vim
                                return a:client['channel']
  119              0.000037   endif
  119              0.000132   return a:client['chan_id']

FUNCTION  <SNR>141_is_jsx_expression()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 76
Called 22 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   22              0.000071   return a:syntax =~? 'jsxExpressionBlock'

FUNCTION  coc#highlight#clear_match_group()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 202
Called 3 times
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
    3              0.000048   let winid = a:winid == 0 ? win_getid() : a:winid
    3              0.000027   if empty(getwininfo(winid))
                                " not valid
                                return
    3              0.000003   endif
    3              0.000005   if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
    3              0.000002   else
    3              0.000007     let curr = win_getid()
    3              0.000013     let switch = exists('*nvim_set_current_win') && curr != winid
    3              0.000003     if switch
                                  noa call nvim_set_current_win(a:winid)
    3              0.000001     endif
    3              0.000004     if win_getid() == winid
    3              0.000159       let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
    9              0.000008       for item in arr
    6              0.000008         call matchdelete(item['id'])
    9              0.000004       endfor
    3              0.000001     endif
    3              0.000002     if switch
                                  noa call nvim_set_current_win(curr)
    3              0.000001     endif
    3              0.000001   endif

FUNCTION  <SNR>105_Nat()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 161
Called 8 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    8              0.000009   return a:int * (a:int > 0)

FUNCTION  gitgutter#async#execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 16
Called 5 times
Total time:   0.020185
 Self time:   0.020017

count  total (s)   self (s)
    5   0.000155   0.000035   call gitgutter#debug#log('[async] '.a:cmd)
                            
    5              0.000017   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000102   0.000054   let command = s:build_command(a:cmd)
                            
    5              0.000007   if has('nvim')
    5              0.019809     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    5              0.000003   endif

FUNCTION  coc#float#create_pum_float()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 880
Called 3 times
Total time:   0.032981
 Self time:   0.010944

count  total (s)   self (s)
    3              0.000014   if !pumvisible() || !s:float_supported
                                return v:null
    3              0.000002   endif
    3              0.000009   let pumbounding = a:config['pumbounding']
    3              0.000010   let pw = pumbounding['width'] + get(pumbounding, 'scrollbar', 0)
    3              0.000009   let rp = &columns - pumbounding['col'] - pw
    3              0.000007   let showRight = pumbounding['col'] > rp ? 0 : 1
    3   0.000084   0.000032   let maxWidth = showRight ? coc#helper#min(rp - 1, a:config['maxWidth']) : coc#helper#min(pumbounding['col'] - 1, a:config['maxWidth'])
    3              0.000009   let maxHeight = &lines - pumbounding['row'] - &cmdheight - 1
    3              0.000004   if maxWidth <= 2 || maxHeight < 1
                                return v:null
    3              0.000001   endif
    3              0.000003   let ch = 0
    3              0.000003   let width = 0
    6              0.000007   for line in a:lines
    3              0.000013     let dw = max([1, strdisplaywidth(line)])
    3              0.000007     let width = max([width, dw + 2])
    3              0.000026     let ch += float2nr(ceil(str2float(string(dw))/(maxWidth - 2)))
    6              0.000004   endfor
    3   0.000060   0.000019   let width = float2nr(coc#helper#min(maxWidth, width))
    3   0.000061   0.000022   let height = float2nr(coc#helper#min(maxHeight, ch))
    3   0.000073   0.000041   let lines = map(a:lines, {_, s -> s =~# '^' ? repeat('', width - 2 + (s:is_vim && ch > height ? -1 : 0)) : s})
    3              0.000027   let opts = { 'lines': lines, 'relative': 'editor', 'col': showRight ? pumbounding['col'] + pw : pumbounding['col'] - width - 1, 'row': pumbounding['row'], 'height': height, 'width': width - 2 + (s:is_vim && ch > height ? -1 : 0), }
    3   0.000233   0.000021   call coc#float#close_auto_hide_wins(a:winid)
    3   0.002294   0.000026   let res = coc#float#create_float_win(a:winid, a:bufnr, opts)
    3              0.000004   if empty(res)
                                return v:null
    3              0.000001   endif
    3   0.019061   0.000028   call coc#highlight#add_highlights(res[0], a:config['codes'], a:config['highlights'])
    3              0.000010   call setwinvar(res[0], 'kind', 'pum')
    3              0.010490   redraw
    3              0.000011   if has('nvim')
    3   0.000387   0.000027     call coc#float#nvim_scrollbar(res[0])
    3              0.000001   endif
    3              0.000002   return res

FUNCTION  <SNR>74_Highlight_Matching_Pair()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\plugin\matchparen.vim line 39
Called 47 times
Total time:   0.014879
 Self time:   0.014879

count  total (s)   self (s)
                              " Remove any previous match.
   47              0.000122   if exists('w:paren_hl_on') && w:paren_hl_on
   35              0.000153     silent! call matchdelete(3)
   35              0.000041     let w:paren_hl_on = 0
   47              0.000017   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   47              0.000126   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   47              0.000014   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   47              0.000074   let c_lnum = line('.')
   47              0.000061   let c_col = col('.')
   47              0.000035   let before = 0
                            
   47              0.000100   let text = getline(c_lnum)
   47              0.000595   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   47              0.000076   if empty(matches)
                                let [c_before, c] = ['', '']
   47              0.000018   else
   47              0.000121     let [c_before, c] = matches[1:2]
   47              0.000015   endif
   47              0.000616   let plist = split(&matchpairs, '.\zs[:,]')
   47              0.000114   let i = index(plist, c)
   47              0.000032   if i < 0
                                " not found, in Insert mode try character before the cursor
   13              0.000035     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    5              0.000010       let before = strlen(c_before)
    5              0.000005       let c = c_before
    5              0.000008       let i = index(plist, c)
   13              0.000005     endif
   13              0.000009     if i < 0
                                  " not found, nothing to do
   12              0.000008       return
    1              0.000000     endif
   35              0.000009   endif
                            
                              " Figure out the arguments for searchpairpos().
   35              0.000026   if i % 2 == 0
    1              0.000001     let s_flags = 'nW'
    1              0.000001     let c2 = plist[i + 1]
   34              0.000010   else
   34              0.000029     let s_flags = 'nbW'
   34              0.000029     let c2 = c
   34              0.000040     let c = plist[i - 1]
   35              0.000010   endif
   35              0.000024   if c == '['
                                let c = '\['
                                let c2 = '\]'
   35              0.000008   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   35              0.000022   if before > 0
    1              0.000003     let has_getcurpos = exists("*getcurpos")
    1              0.000001     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    1              0.000002       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    1              0.000000     endif
    1              0.000003     call cursor(c_lnum, c_col - before)
   35              0.000010   endif
                            
   35              0.000112   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   35              0.000010   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   35              0.000093     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   35              0.000030     try
   35              0.004188       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   35              0.000030     endtry
   35              0.000011   endif
                            
                              " Limit the search to lines visible in the window.
   35              0.000071   let stoplinebottom = line('w$')
   35              0.000053   let stoplinetop = line('w0')
   35              0.000028   if i % 2 == 0
    1              0.000001     let stopline = stoplinebottom
   34              0.000010   else
   34              0.000061     let stopline = stoplinetop
   35              0.000010   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   35              0.000076   if mode() == 'i' || mode() == 'R'
   31              0.000102     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    4              0.000001   else
    4              0.000012     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   35              0.000012   endif
   35              0.000016   try
   35              0.003658     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   35              0.000017   endtry
                            
   35              0.000026   if before > 0
    1              0.000001     if has_getcurpos
    1              0.000002       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    1              0.000000     endif
   35              0.000009   endif
                            
                              " If a match is found setup match highlighting.
   35              0.000062   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   35              0.000054     if exists('*matchaddpos')
   35              0.000564       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   35              0.000012     endif
   35              0.000039     let w:paren_hl_on = 1
   35              0.000012   endif

FUNCTION  <SNR>141_is_jsx_brace()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 81
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000012   return a:syntax =~? 'jsxBraces'

FUNCTION  coc#util#do_autocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 708
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000041   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
    6              0.000002   endif

FUNCTION  <SNR>141_start_syntax()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 40
Called 4 times
Total time:   0.000151
 Self time:   0.000040

count  total (s)   self (s)
    4   0.000149   0.000038   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  <SNR>23_AsyncRequest()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 109
Called 7 times
Total time:   0.000654
 Self time:   0.000163

count  total (s)   self (s)
    7              0.000046   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    7              0.000015   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    7              0.000002   endif
    7   0.000528   0.000037   call coc#rpc#notify(a:name, a:args)
    7              0.000003   return ''

FUNCTION  coc#util#get_format_opts()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 914
Called 4 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    4              0.000029   if a:bufnr && bufloaded(a:bufnr)
    4              0.000021     let tabsize = getbufvar(a:bufnr, '&shiftwidth')
    4              0.000004     if tabsize == 0
                                  let tabsize = getbufvar(a:bufnr, '&tabstop')
    4              0.000002     endif
    4              0.000014     return [tabsize, getbufvar(a:bufnr, '&expandtab')]
                              endif
                              let tabsize = &shiftwidth == 0 ? &tabstop : &shiftwidth
                              return [tabsize, &expandtab]

FUNCTION  coc#highlight#compose_hlgroup()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 131
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000008   let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
    3              0.000004   if a:fgGroup == a:bgGroup
    3              0.000003     return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup

FUNCTION  <SNR>105_SkipFunc()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 114
Called 3 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    3              0.000003   if s:top_col == 1
                                throw 'out of bounds'
    3              0.000002   elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
    3              0.000035   elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
    3              0.000017   elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
    3              0.000001   else
    3              0.000015     let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
    3              0.000001   endif
    3              0.000009   let [s:looksyn, s:top_col] = getpos('.')[1:2]

FUNCTION  coc#_insert_key()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 49
Called 6 times
Total time:   0.000340
 Self time:   0.000129

count  total (s)   self (s)
    6              0.000056   if get(a:, 1, 1)
    6   0.000246   0.000036     call coc#_cancel()
    6              0.000002   endif
    6              0.000025   return "\<c-r>=coc#rpc#".a:method."('doKeymap', ['".a:key."'])\<CR>"

FUNCTION  coc#float#check_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 796
Called 7 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
    7              0.000011   let invalids = []
    7              0.000007   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
    7              0.000003   else
   14              0.000030     for i in range(1, winnr('$'))
    7              0.000018       let target = getwinvar(i, 'target_winid', 0)
    7              0.000010       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
    7              0.000014       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
    7              0.000002       endif
   14              0.000008     endfor
    7              0.000003   endif
    7              0.000008   for id in invalids
                                call coc#float#close(id)
    7              0.000003   endfor

FUNCTION  <SNR>141_syntax_at()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 30
Called 4 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    4              0.000057   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  jsx_pretty#indent#get()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 240
Called 4 times
Total time:   0.006227
 Self time:   0.000409

count  total (s)   self (s)
    4   0.000070   0.000026   let line = s:trim(getline(v:lnum))
    4   0.000174   0.000023   let start_syntax = s:start_syntax(v:lnum)
                            
    4   0.000075   0.000036   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
    4              0.000002   endif
                            
    4   0.000029   0.000016   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
    4              0.000001   endif
                            
    4   0.000029   0.000018   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
    4              0.000001   endif
                            
    4   0.001332   0.000022   let syntax_context = s:syntax_context(v:lnum)
                            
    4              0.000004   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
    4              0.000004   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
    4              0.000004   elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
    4              0.000004   elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
    4              0.000001   endif
                            
    4   0.004271   0.000019   return a:js_indent()

FUNCTION  coc#util#cursor()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 35
Called 12 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
   12              0.000110   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 196
Called 5 times
Total time:   0.000943
 Self time:   0.000943

count  total (s)   self (s)
    5              0.000836   let p = resolve(expand('#'.a:bufnr.':p'))
    5              0.000068   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    5              0.000012   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    5              0.000002   endif
    5              0.000008   return g:gitgutter_diff_base

FUNCTION  coc#float#create_float_win()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 66
Called 3 times
Total time:   0.002268
 Self time:   0.000746

count  total (s)   self (s)
    3              0.000008   let lines = get(a:config, 'lines', v:null)
    3   0.000223   0.000020   let bufnr = coc#float#create_buf(a:bufnr, lines, 'hide')
                              " use exists
    3              0.000005   if a:winid && coc#float#valid(a:winid)
                                if s:is_vim
                                  let [line, col] = s:popup_position(a:config)
                                  let opts = { 'firstline': 1, 'line': line, 'col': col, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'cursorline': get(a:config, 'cursorline', 0), 'title': get(a:config, 'title', ''), }
                                  if !s:empty_border(get(a:config, 'border', []))
                                    let opts['border'] = a:config['border']
                                  endif
                                  call popup_setoptions(a:winid, opts)
                                  call coc#float#vim_buttons(a:winid, a:config)
                                  return [a:winid, winbufnr(a:winid)]
                                else
                                  let config = s:convert_config_nvim(a:config)
                                  call nvim_win_set_buf(a:winid, bufnr)
                                  call nvim_win_set_config(a:winid, config)
                                  call nvim_win_set_cursor(a:winid, [1, 0])
                                  call coc#float#nvim_create_related(a:winid, config, a:config)
                                  return [a:winid, bufnr]
                                endif
    3              0.000001   endif
    3              0.000003   let winid = 0
    3              0.000002   if s:is_vim
                                let [line, col] = s:popup_position(a:config)
                                let title = get(a:config, 'title', '')
                                let buttons = get(a:config, 'buttons', [])
                                let hlgroup = get(a:config, 'highlight',  'CocFloating')
                                let opts = { 'title': title, 'line': line, 'col': col, 'fixed': 1, 'padding': empty(title) ?  [0, 1, 0, 1] : [0, 0, 0, 0], 'borderchars': s:borderchars, 'highlight': hlgroup, 'cursorline': get(a:config, 'cursorline', 0), 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'] }
                                if get(a:config, 'close', 0)
                                  let opts['close'] = 'button'
                                endif
                                if !empty(get(a:config, 'borderhighlight', []))
                                  let opts['borderhighlight'] = map(a:config['borderhighlight'], 'coc#highlight#compose_hlgroup(v:val,"'.hlgroup.'")')
                                endif
                                if !s:empty_border(get(a:config, 'border', []))
                                  let opts['border'] = a:config['border']
                                endif
                                let winid = popup_create(bufnr, opts)
                                if winid == 0
                                  return []
                                endif
                                call coc#float#vim_buttons(winid, a:config)
                                if has("patch-8.1.2281")
                                  call setwinvar(winid, '&showbreak', 'NONE')
                                endif
    3              0.000001   else
    3   0.000280   0.000024     let config = s:convert_config_nvim(a:config)
    3              0.000166     let winid = nvim_open_win(bufnr, 0, config)
    3              0.000004     if winid == 0
                                  return []
    3              0.000001     endif
    3              0.000008     let hlgroup = get(a:config, 'highlight', 'CocFloating')
    3              0.000053     call setwinvar(winid, '&winhl', 'Normal:'.hlgroup.',NormalNC:'.hlgroup.',FoldColumn:'.hlgroup)
    3              0.000013     call setwinvar(winid, '&signcolumn', 'no')
                                " cursorline highlight not work on old neovim
    3              0.000012     call setwinvar(winid, '&cursorline', 0)
    3              0.000010     call setwinvar(winid, 'border', get(a:config, 'border', []))
                                " no left border
    3   0.000030   0.000022     if s:empty_border(get(a:config, 'border', [])) || a:config['border'][3] == 0
    3              0.000012       call setwinvar(winid, '&foldcolumn', 1)
    3              0.000001     endif
    3              0.000014     call nvim_win_set_cursor(winid, [1, 0])
    3   0.001046   0.000026     call coc#float#nvim_create_related(winid, config, a:config)
    3              0.000001   endif
    3              0.000006   if get(a:config, 'autohide', 0)
                                call setwinvar(winid, 'autohide', 1)
    3              0.000001   endif
    3              0.000011   if s:is_vim || has('nvim-0.5.0')
                                call setwinvar(winid, '&scrolloff', 0)
    3              0.000001   endif
    3              0.000006   call setwinvar(winid, 'float', 1)
    3              0.000009   call setwinvar(winid, '&list', 0)
    3              0.000008   call setwinvar(winid, '&number', 0)
    3              0.000008   call setwinvar(winid, '&relativenumber', 0)
    3              0.000008   call setwinvar(winid, '&cursorcolumn', 0)
    3              0.000011   call setwinvar(winid, '&colorcolumn', 0)
    3              0.000008   call setwinvar(winid, '&wrap', 1)
    3              0.000007   call setwinvar(winid, '&linebreak', 1)
    3              0.000009   call setwinvar(winid, '&conceallevel', 2)
    3              0.000009   let g:coc_last_float_win = winid
    3   0.000054   0.000020   call coc#util#do_autocmd('CocOpenFloat')
    3              0.000005   return [winid, bufnr]

FUNCTION  <SNR>141_is_opening_tag()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 56
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000010   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  coc#compat#execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\compat.vim line 113
Called 3 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
    3              0.000004   if s:is_vim
                                if !exists('*win_execute')
                                  throw 'win_execute function not exists, please upgrade your vim.'
                                endif
                                if type(a:command) == v:t_string
                                  keepalt call win_execute(a:winid, a:command)
                                elseif type(a:command) == v:t_list
                                  keepalt call win_execute(a:winid, join(a:command, "\n"))
                                endif
    3              0.000001   else
    3              0.000006     let curr = nvim_get_current_win()
    3              0.000024     noa keepalt call nvim_set_current_win(a:winid)
    3              0.000006     if type(a:command) == v:t_string
    3              0.000316       exec a:command
                                elseif type(a:command) == v:t_list
                                  exec join(a:command, "\n")
    3              0.000001     endif
    3              0.000021     noa keepalt call nvim_set_current_win(curr)
    3              0.000001   endif

FUNCTION  coc#rpc#request()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 88
Called 8 times
Total time:   0.266289
 Self time:   0.000118

count  total (s)   self (s)
    8   0.000078   0.000032   if !coc#rpc#ready()
                                return ''
    8              0.000003   endif
    8   0.266196   0.000071   return s:client['request'](a:method, a:args)

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 28
Called 5 times
Total time:   0.000176
 Self time:   0.000062

count  total (s)   self (s)
    5   0.000092   0.000026   let summary = gitgutter#hunk#summary(a:bufnr)
    5              0.000006   let summary[0] += a:count
    5   0.000073   0.000026   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  coc#float#get_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1207
Called 20 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   26              0.000083   for winid in getwinvar(a:winid, 'related', [])
    6              0.000012     if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
    6              0.000002     endif
   26              0.000017   endfor
   20              0.000014   return 0

FUNCTION  gitgutter#hunk#summary()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 20
Called 5 times
Total time:   0.000066
 Self time:   0.000033

count  total (s)   self (s)
    5   0.000064   0.000030   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  coc#_hide()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 97
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000009   if !pumvisible() | return | endif
                              call feedkeys("\<C-e>", 'in')

FUNCTION  <SNR>59_build_command()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 43
Called 5 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    5              0.000015   if has('unix')
                                return ['sh', '-c', a:cmd]
    5              0.000002   endif
                            
    5              0.000005   if has('win32')
    5              0.000015     return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  coc#util#set_lines()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 557
Called 1 time
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
    1              0.000003   if !s:is_vim
    1              0.000025     call nvim_buf_set_lines(a:bufnr, a:start, a:end, 0, a:replacement)
                              else
                                call coc#api#notify('buf_set_lines', [a:bufnr, a:start, a:end, 0, a:replacement])
    1              0.000000   endif
    1              0.000245   return { 'lines': getbufline(a:bufnr, 1, '$'), 'changedtick': getbufvar(a:bufnr, 'changedtick') }

FUNCTION  <SNR>141_trim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 20
Called 4 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    4              0.000041   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>105_IsContOne()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 297
Called 2 times
Total time:   0.000704
 Self time:   0.000095

count  total (s)   self (s)
    2   0.000017   0.000013   let [l:num, pind] = b:js_cache[1] ? [b:js_cache[1], indent(b:js_cache[1]) + s:sw()] : [1,0]
    2              0.000005   let [ind, b_l] = [indent('.') + !a:cont, 0]
    4              0.000010   while line('.') > l:num && ind > pind || line('.') == l:num
    4   0.000543   0.000019     if indent('.') < ind && s:OneScope()
    2              0.000002       let b_l += 1
    2              0.000004     elseif !a:cont || b_l || ind < indent(a:firstline)
    2              0.000001       break
                                else
                                  call cursor(0,1)
    2              0.000001     endif
    2              0.000005     let ind = min([ind, indent('.')])
    2   0.000091   0.000009     if s:PreviousToken() is ''
                                  break
    2              0.000001     endif
    4              0.000003   endwhile
    2              0.000001   return b_l

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 102
Called 15 times
Total time:   0.000381
 Self time:   0.000126

count  total (s)   self (s)
   15   0.000374   0.000119   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>141_is_jsx_region()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 66
Called 22 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   22              0.000052   return a:syntax =~? 'jsxRegion'

FUNCTION  <SNR>128_is_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 273
Called 5 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    5              0.000007   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>105_GetPair()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 75
Called 7 times
Total time:   0.000710
 Self time:   0.000214

count  total (s)   self (s)
    7   0.000705   0.000209     return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)

FUNCTION  coc#_do_complete()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 68
Called 3 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    3              0.000082   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    3              0.000025   if mode() =~# 'i' && &paste != 1
    3              0.000017     call feedkeys("\<Plug>CocRefresh", 'i')
    3              0.000002   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 164
Called 5 times
Total time:   0.001445
 Self time:   0.000109

count  total (s)   self (s)
    5   0.000716   0.000074   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    5   0.000725   0.000031   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>51_onCursorHold()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 187
Called 7 times
Total time:   0.022795
 Self time:   0.000382

count  total (s)   self (s)
                                " Do not update when a special buffer is selected
    7              0.000022     if !empty(&l:buftype)
                                    return
    7              0.000003     endif
    7              0.000060     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
                            
    7   0.000084   0.000048     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    7              0.000002     endif
                            
    7   0.021968   0.000077     let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
    7   0.000626   0.000140     call s:logger.debug('run cursor-hold job: ' . l:job.id)

FUNCTION  coc#util#get_complete_option()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 329
Called 3 times
Total time:   0.001079
 Self time:   0.001079

count  total (s)   self (s)
    3              0.000024   let pos = getcurpos()
    3              0.000012   let line = getline(pos[1])
    3              0.000053   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
    3              0.000010   let col = pos[2] - strlen(input)
    3              0.000409   let synname = synIDattr(synID(pos[1], col, 1), 'name')
    3              0.000559   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  <SNR>105_Token()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 169
Called 16 times
Total time:   0.000237
 Self time:   0.000150

count  total (s)   self (s)
   16   0.000232   0.000145   return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()

FUNCTION  gitgutter#diff#parse_diff()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 205
Called 5 times
Total time:   0.001436
 Self time:   0.000590

count  total (s)   self (s)
    5              0.000008   let hunks = []
   58              0.000091   for line in split(a:diff, '\n')
   53   0.001135   0.000290     let hunk_info = gitgutter#diff#parse_hunk(line)
   53              0.000061     if len(hunk_info) == 4
    5              0.000008       call add(hunks, hunk_info)
   53              0.000018     endif
   58              0.000024   endfor
    5              0.000004   return hunks

FUNCTION  <SNR>26_request()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\client.vim line 148
Called 8 times
Total time:   0.266124
 Self time:   0.264905

count  total (s)   self (s)
    8   0.000076   0.000044   let channel = coc#client#get_channel(self)
    8              0.000015   if empty(channel) | return '' | endif
    8              0.000005   try
    8              0.000005     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    8              0.000003     else
    8   0.265742   0.264553       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    8              0.000005   endtry

FUNCTION  gitgutter#diff#process_hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 231
Called 5 times
Total time:   0.000691
 Self time:   0.000077

count  total (s)   self (s)
    5              0.000006   let modified_lines = []
   10              0.000010   for hunk in a:hunks
    5   0.000651   0.000037     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   10              0.000005   endfor
    5              0.000004   return modified_lines

FUNCTION  coc#highlight#add_highlight()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 41
Called 34 times
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
   34              0.000055   if has('nvim')
   34              0.000285     call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
   34              0.000025   endif

FUNCTION  <SNR>132_create_namespace()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 300
Called 18 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   18              0.000023   if type(a:key) == 0
    3              0.000002     return a:key
   15              0.000004   endif
   15              0.000044   if has('nvim')
   15              0.000037     return nvim_create_namespace('coc-'.a:key)
                              endif
                              if !has_key(s:namespace_map, a:key)
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]

FUNCTION  <SNR>66_CursorHoldUpdate()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-devicons\plugin\webdevicons.vim line 397
Called 7 times
Total time:   0.000374
 Self time:   0.000079

count  total (s)   self (s)
    7              0.000019   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    7              0.000002   endif
                            
    7   0.000335   0.000039   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    7              0.000003     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  coc#util#echo_messages()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 163
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000053   if a:hl !~# 'Error' && (mode() !~# '\v^(i|n)$')
                                return
    1              0.000001   endif
    1              0.000022   let msgs = filter(copy(a:msgs), '!empty(v:val)')
    1              0.000001   if empty(msgs)
                                return
    1              0.000000   endif
    1              0.000024   execute 'echohl '.a:hl
    1              0.000039   echom a:msgs[0]
    1              0.000003   redraw
    1              0.000006   echo join(msgs, "\n")
    1              0.000010   echohl None

FUNCTION  gitgutter#debug#log()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\debug.vim line 70
Called 10 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   10              0.000010   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   10              0.000003   endif

FUNCTION  <SNR>84_setup_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 156
Called 15 times
Total time:   0.000469
 Self time:   0.000088

count  total (s)   self (s)
   15   0.000461   0.000080   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  186()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\creator.vim line 37
Called 15 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
   15              0.000012     return 'NERD_tree_'

FUNCTION  coc#highlight#ranges()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 15
Called 12 times
Total time:   0.002441
 Self time:   0.001869

count  total (s)   self (s)
   12              0.000026   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
   12              0.000044   if !bufloaded(bufnr) || !exists('*getbufline')
                                return
   12              0.000003   endif
   12   0.000154   0.000060   let srcId = s:create_namespace(a:key)
   46              0.000034   for range in a:ranges
   34              0.000051     let start = range['start']
   34              0.000030     let end = range['end']
   68              0.000108     for lnum in range(start['line'] + 1, end['line'] + 1)
   34              0.000066       let arr = getbufline(bufnr, lnum)
   34              0.000074       let line = empty(arr) ? '' : arr[0]
   34              0.000033       if empty(line)
                                    continue
   34              0.000010       endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
   34              0.000134       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
   34              0.000123       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
   34              0.000046       if colStart == colEnd
                                    continue
   34              0.000010       endif
   34   0.000760   0.000281       call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
   68              0.000025     endfor
   46              0.000039   endfor

FUNCTION  gitstatus#job#Spawn()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 132
Called 8 times
Total time:   0.024218
 Self time:   0.000125

count  total (s)   self (s)
    8   0.000215   0.000055     let l:job = s:newJob(a:name, a:opts)
    8   0.023985   0.000052     call l:job.run(a:cmd)
    8              0.000011     return l:job

FUNCTION  gitgutter#hunk#hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 10
Called 5 times
Total time:   0.000068
 Self time:   0.000031

count  total (s)   self (s)
    5   0.000066   0.000028   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitstatus#util#ParseGitStatusLine()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 174
Called 8 times
Total time:   0.000397
 Self time:   0.000302

count  total (s)   self (s)
    8              0.000022     if get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2
    8              0.000012         if a:statusLine[0] ==# '1'
    8   0.000180   0.000086             let l:statusKey = s:getStatusKey(a:statusLine[2], a:statusLine[3])
    8              0.000013             let l:pathStr = a:statusLine[113:]
                                    elseif a:statusLine[0] ==# '2'
                                        let l:statusKey = 'Renamed'
                                        let l:pathStr = a:statusLine[113:]
                                        let l:pathStr = l:pathStr[stridx(l:pathStr, ' ')+1:]
                                    elseif a:statusLine[0] ==# 'u'
                                        let l:statusKey = 'Unmerged'
                                        let l:pathStr = a:statusLine[161:]
                                    elseif a:statusLine[0] ==# '?'
                                        let l:statusKey = 'Untracked'
                                        let l:pathStr = a:statusLine[2:]
                                    elseif a:statusLine[0] ==# '!'
                                        let l:statusKey = 'Ignored'
                                        let l:pathStr = a:statusLine[2:]
                                    else
                                        throw '[nerdtree_git_status] unknown status: ' . a:statusLine
    8              0.000017         endif
    8              0.000013         return [l:pathStr, l:statusKey]
                                else
                                    let l:pathStr = a:statusLine[3:]
                                    let l:statusKey = s:getStatusKey(a:statusLine[0], a:statusLine[1])
                                    return [l:pathStr, l:statusKey]
                                endif

FUNCTION  coc#_cancel()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 102
Called 9 times
Total time:   0.000300
 Self time:   0.000175

count  total (s)   self (s)
                              " hack for close pum
    9              0.000028   if pumvisible()
    2              0.000062     let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
    2              0.000009     call feedkeys("\<Plug>CocRefresh", 'i')
    2   0.000134   0.000009     call coc#rpc#notify('stopCompletion', [])
    9              0.000004   endif

FUNCTION  <SNR>95_getStatusKey()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 149
Called 8 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    8              0.000014     let l:xy = a:x . a:y
    8              0.000016     if get(s:unmerged_status, l:xy, 0)
                                    return 'Unmerged'
    8              0.000023     elseif l:xy ==# '??'
                                    return 'Untracked'
    8              0.000006     elseif l:xy ==# '!!'
                                    return 'Ignored'
    8              0.000006     elseif a:y ==# 'M'
    8              0.000005         return 'Modified'
                                elseif a:y ==# 'D'
                                    return 'Deleted'
                                elseif a:y =~# '[RC]'
                                    return 'Renamed'
                                elseif a:x ==# 'D'
                                    return 'Deleted'
                                elseif a:x =~# '[MA]'
                                    return 'Staged'
                                elseif a:x =~# '[RC]'
                                    return 'Renamed'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  <SNR>105_sw()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 55
Called 6 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    6              0.000007     return shiftwidth()

FUNCTION  <SNR>51_onGitStatusSuccessCB()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 160
Called 8 times
Total time:   0.001803
 Self time:   0.000311

count  total (s)   self (s)
    8              0.000033     if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
                                    call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
                                    return
    8              0.000003     endif
    8              0.000030     let l:output = join(a:job.chunks, '')
    8              0.000071     let l:lines = split(l:output, "\n")
    8   0.001235   0.000065     let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
                            
    8   0.000056   0.000035     call s:listener.SetNext(l:cache)
    8   0.000326   0.000024     call s:listener.TryUpdateNERDTreeUI()

FUNCTION  <SNR>105_OneScope()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 263
Called 4 times
Total time:   0.000524
 Self time:   0.000109

count  total (s)   self (s)
    4   0.000226   0.000024   if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
    2   0.000095   0.000012     let tok = s:PreviousToken()
    2   0.000134   0.000028     return (count(split('for if let while with'),tok) || tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') && s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
    2   0.000040   0.000018   elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
    2              0.000005   elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                return s:PreviousToken() != ')' || s:GetPair('(', ')', 'bW', s:skip_expr)
    2              0.000001   endif

FUNCTION  <SNR>85_close_win()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1529
Called 3 times
Total time:   0.000628
 Self time:   0.000074

count  total (s)   self (s)
    3              0.000003   if a:winid == 0
                                return
    3              0.000001   endif
                              " vim not throw for none exists winid
    3              0.000002   if s:is_vim
                                call popup_close(a:winid)
    3              0.000001   else
    3              0.000005     if nvim_win_is_valid(a:winid)
    3   0.000603   0.000049       call nvim_win_close(a:winid, 1)
    3              0.000001     endif
    3              0.000001   endif

FUNCTION  <SNR>128_write_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 375
Called 5 times
Total time:   4.036719
 Self time:   4.036719

count  total (s)   self (s)
    5              0.001344   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    5              0.000014   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    5              0.000002   endif
                            
    5              0.000017   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
    5              0.005543     call map(bufcontents, 'v:val."\r"')
    5              0.000009   endif
                            
    5              0.000021   if getbufvar(a:bufnr, '&endofline')
    5              0.000010     call add(bufcontents, '')
    5              0.000002   endif
                            
    5              0.000016   let fenc = getbufvar(a:bufnr, '&fileencoding')
    5              0.000007   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    5              0.000002   endif
                            
    5              0.000012   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
    5              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    5              0.000003   try
    5              4.029559     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    5              0.000005   endtry

FUNCTION  <SNR>141_is_jsx_element()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 71
Called 22 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
   22              0.000083   return a:syntax =~? 'jsxElement'

FUNCTION  gitgutter#all()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 3
Called 2 times
Total time:   0.090106
 Self time:   0.002316

count  total (s)   self (s)
    2              0.000015   let visible = tabpagebuflist()
                            
   94              0.000099   for bufnr in range(1, bufnr('$') + 1)
   92              0.000138     if buflisted(bufnr)
    8              0.001085       let file = expand('#'.bufnr.':p')
    8              0.000027       if !empty(file)
    8              0.000028         if index(visible, bufnr) != -1
    2   0.087595   0.000026           call gitgutter#process_buffer(bufnr, a:force)
    6              0.000009         elseif a:force
    6   0.000302   0.000081           call s:reset_tick(bufnr)
    8              0.000008         endif
    8              0.000005       endif
   92              0.000039     endif
   94              0.000043   endfor

FUNCTION  gitgutter#utility#extension()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 88
Called 5 times
Total time:   0.000722
 Self time:   0.000037

count  total (s)   self (s)
    5   0.000720   0.000035   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  coc#float#get_float_win_list()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 599
Called 3 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    3              0.000005   if s:is_vim && exists('*popup_list')
                                return filter(popup_list(), 'popup_getpos(v:val)["visible"]')
    3              0.000014   elseif has('nvim') && exists('*nvim_win_get_config')
    3              0.000003     let res = []
    6              0.000032     for i in range(1, winnr('$'))
    3              0.000006       let id = win_getid(i)
    3              0.000018       let config = nvim_win_get_config(id)
                                  " ignore border & button window
    3              0.000013       if (!empty(config) && !empty(config['relative']) && !getwinvar(id, 'target_winid', 0))
                                    call add(res, id)
    3              0.000001       endif
    6              0.000004     endfor
    3              0.000016     return res
                              endif
                              return []

FUNCTION  <SNR>99_isEOF()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 128
Called 8 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    8              0.000049     return len(a:data) == 1 && a:data[0] is# ''

FUNCTION  <SNR>105_PreviousToken()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 173
Called 14 times
Total time:   0.000678
 Self time:   0.000464

count  total (s)   self (s)
   14              0.000037   let [l:pos, tok] = [getpos('.'), '']
   14              0.000096   if search('\m\k\{1,}\|\S','ebW')
   14              0.000037     if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
   14              0.000004     else
   14              0.000057       let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
   14              0.000014       if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
   14              0.000004       else
   14   0.000264   0.000050         let tok = s:Token()
   14              0.000005       endif
   14              0.000003     endif
   14              0.000004   endif
   14              0.000008   return tok

FUNCTION  coc#float#close()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 568
Called 3 times
Total time:   0.001498
 Self time:   0.000057

count  total (s)   self (s)
    3   0.000043   0.000016   if !coc#float#valid(a:winid)
                                return 0
    3              0.000001   endif
    3   0.000801   0.000015   call coc#float#close_related(a:winid)
    3   0.000645   0.000017   call s:close_win(a:winid)
    3              0.000001   return 1

FUNCTION  coc#rpc#ready()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 31
Called 119 times
Total time:   0.000719
 Self time:   0.000719

count  total (s)   self (s)
  119              0.000418   if empty(s:client) || s:client['running'] == 0
                                return 0
  119              0.000040   endif
  119              0.000067   return 1

FUNCTION  <SNR>51_refreshGitStatus()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 149
Called 8 times
Total time:   0.024679
 Self time:   0.000224

count  total (s)   self (s)
    8              0.000063     let l:opts =  { 'on_failed_cb': function('s:onGitStatusFailedCB'), 'on_success_cb': function('s:onGitStatusSuccessCB'), 'cwd': a:workdir }
    8   0.024581   0.000125     let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
    8              0.000025     return l:job

FUNCTION  coc#float#close_auto_hide_wins()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 736
Called 3 times
Total time:   0.000212
 Self time:   0.000052

count  total (s)   self (s)
    3   0.000180   0.000020   let winids = coc#float#get_float_win_list()
    3              0.000007   let except = get(a:, 1, 0)
    3              0.000004   for id in winids
                                if except && id == except
                                  continue
                                endif
                                if getwinvar(id, 'autohide', 0)
                                  call coc#float#close(id)
                                endif
    3              0.000002   endfor

FUNCTION  gitgutter#utility#shellescape()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 73
Called 25 times
Total time:   0.000611
 Self time:   0.000500

count  total (s)   self (s)
   25              0.000238   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    5              0.000004     return a:arg
   20   0.000210   0.000099   elseif s:winshell()
   20              0.000113     return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  <SNR>85_empty_border()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 925
Called 9 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    9              0.000012   if empty(a:border)
    9              0.000006     return 1
                              endif
                              if a:border[0] == 0 && a:border[1] == 0 && a:border[2] == 0 && a:border[3] == 0
                                return 1
                              endif
                              return 0

FUNCTION  gitgutter#async#available()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 11
Called 5 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    5              0.000005   return s:available

FUNCTION  <SNR>57_abs_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 205
Called 45 times
Total time:   0.006588
 Self time:   0.006588

count  total (s)   self (s)
   45              0.005625   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   45              0.000741   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   45              0.000112   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 216
Called 53 times
Total time:   0.000846
 Self time:   0.000846

count  total (s)   self (s)
   53              0.000336   let matches = matchlist(a:line, s:hunk_re)
   53              0.000062   if len(matches) > 0
    5              0.000011     let from_line  = str2nr(matches[1])
    5              0.000014     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    5              0.000008     let to_line    = str2nr(matches[3])
    5              0.000012     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    5              0.000009     return [from_line, from_count, to_line, to_count]
   48              0.000018   else
   48              0.000026     return []
                              end

FUNCTION  coc#float#create_buf()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 1217
Called 6 times
Total time:   0.000614
 Self time:   0.000607

count  total (s)   self (s)
    6              0.000014   if a:bufnr > 0 && bufloaded(a:bufnr)
    3              0.000003     let bufnr = a:bufnr
    3              0.000001   else
    3              0.000002     if s:is_vim
                                  noa let bufnr = bufadd('')
                                  noa call bufload(bufnr)
                                  call setbufvar(bufnr, '&buflisted', 0)
    3              0.000001     else
    3              0.000206       noa let bufnr = nvim_create_buf(v:false, v:true)
    3              0.000002     endif
    3              0.000009     let bufhidden = get(a:, 2, 'wipe')
    3   0.000023   0.000020     call setbufvar(bufnr, '&buftype', 'nofile')
    3   0.000016   0.000015     call setbufvar(bufnr, '&bufhidden', bufhidden)
    3   0.000014   0.000013     call setbufvar(bufnr, '&swapfile', 0)
    3   0.000016   0.000015     call setbufvar(bufnr, '&undolevels', -1)
                                " neovim's bug
    3   0.000013   0.000013     call setbufvar(bufnr, '&modifiable', 1)
    6              0.000003   endif
    6              0.000015   let lines = get(a:, 1, v:null)
    6              0.000009   if type(lines) != 7
    6              0.000012     if has('nvim')
    6              0.000101       call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                else
                                  call deletebufline(bufnr, 1, '$')
                                  call setbufline(bufnr, 1, lines)
    6              0.000002     endif
    6              0.000002   endif
    6              0.000005   return bufnr

FUNCTION  CocActionAsync()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 79
Called 7 times
Total time:   0.000729
 Self time:   0.000075

count  total (s)   self (s)
    7   0.000723   0.000068   return s:AsyncRequest(a:name, a:000)

FUNCTION  <SNR>61_addtomrufs()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\ctrlp.vim\autoload\ctrlp\mrufiles.vim line 70
Called 1 time
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
    1              0.000096 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    1              0.000027 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    1              0.000032 	let abs_fn = fnamemodify(fn,':p')
    1              0.000139 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    1              0.000001 	en
    1              0.000007 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    1              0.000001 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    1              0.000000 	en

FUNCTION  coc#util#check_refresh()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 61
Called 5 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    5              0.000021   if !bufloaded(a:bufnr)
                                return 0
    5              0.000003   endif
    5              0.000012   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    5              0.000001   endif
    5              0.000009   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    5              0.000001   endif
    5              0.000003   return 1

FUNCTION  <SNR>51_buildGitStatusCommand()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 145
Called 8 times
Total time:   0.000238
 Self time:   0.000065

count  total (s)   self (s)
    8   0.000235   0.000062     return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)

FUNCTION  gitgutter#sign#update_signs()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 57
Called 5 times
Total time:   0.000617
 Self time:   0.000526

count  total (s)   self (s)
    5              0.000009   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    5              0.000025     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    5   0.000070   0.000033     let modified_lines = s:handle_double_hunk(a:modified_lines)
    5   0.000305   0.000251     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    5              0.000008     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
    5              0.000002     endif
                            
   33              0.000021     for sign in signs
   28              0.000114       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
   33              0.000013     endfor
    5              0.000002     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>23_SyncAutocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 235
Called 1 time
Total time:   0.258823
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002   if !g:coc_workspace_initialized
                                return
    1              0.000001   endif
    1              0.000001   if g:coc_service_initialized
    1   0.258813   0.000007     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    1              0.000000   endif

FUNCTION  <SNR>128_process_added()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 293
Called 5 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    5              0.000004   let offset = 0
   33              0.000028   while offset < a:to_count
   28              0.000034     let line_number = a:to_line + offset
   28              0.000051     call add(a:modifications, [line_number, 'added'])
   28              0.000023     let offset += 1
   33              0.000014   endwhile

FUNCTION  <SNR>57_exists_file()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 223
Called 15 times
Total time:   0.004054
 Self time:   0.001021

count  total (s)   self (s)
   15   0.004044   0.001011   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  gitstatus#util#BuildGitStatusCommand()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 59
Called 8 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    8              0.000052     let l:cmd = [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'status', '--porcelain' . (get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2 ? '=v2' : ''), '-z' ]
    8              0.000015     if has_key(a:opts, 'NERDTreeGitStatusUntrackedFilesMode')
    8              0.000027         let l:cmd += ['--untracked-files=' . a:opts['NERDTreeGitStatusUntrackedFilesMode']]
    8              0.000003     endif
                            
    8              0.000014     if get(a:opts, 'NERDTreeGitStatusShowIgnored', 0)
                                    let l:cmd += ['--ignored=traditional']
    8              0.000002     endif
                            
    8              0.000011     if has_key(a:opts, 'NERDTreeGitStatusIgnoreSubmodules')
                                    let l:cmd += ['--ignore-submodules=' . a:opts['NERDTreeGitStatusIgnoreSubmodules']]
    8              0.000002     endif
                            
    8              0.000005     return l:cmd

FUNCTION  GetJsxIndent()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\after\indent\jsx.vim line 28
Called 4 times
Total time:   0.006266
 Self time:   0.000038

count  total (s)   self (s)
    4   0.006263   0.000036   return jsx_pretty#indent#get(function('GetJavascriptIndent'))

FUNCTION  <SNR>61_record()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\ctrlp.vim\autoload\ctrlp\mrufiles.vim line 59
Called 4 times
Total time:   0.000372
 Self time:   0.000057

count  total (s)   self (s)
    4              0.000006 	if s:locked | retu | en
    4              0.000006 	let bufnr = a:bufnr + 0
    4              0.000007 	let bufname = bufname(bufnr)
    4              0.000006 	if bufnr > 0 && !empty(bufname)
    1              0.000005 		cal filter(s:mrbs, 'v:val != bufnr')
    1              0.000002 		cal insert(s:mrbs, bufnr)
    1   0.000321   0.000006 		cal s:addtomrufs(bufname)
    4              0.000001 	en

FUNCTION  gitgutter#utility#setbufvar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 9
Called 26 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
   26              0.000042   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   26              0.000070   let ggvars = getbufvar(buffer, 'gitgutter')
   26              0.000050   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   26              0.000010   endif
   26              0.000072   let ggvars[a:varname] = a:val

FUNCTION  <SNR>57_winshell()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 68
Called 20 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   20              0.000101   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>84_has_fresh_changes()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 162
Called 13 times
Total time:   0.000159
 Self time:   0.000079

count  total (s)   self (s)
   13   0.000155   0.000075   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  291()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 48
Called 8 times
Total time:   0.001974
 Self time:   0.000074

count  total (s)   self (s)
    8              0.000014     let self.running = 0
    8              0.000008     if self.failed
                                    call self.onFailed()
    8              0.000004     else
    8   0.001926   0.000026         call self.onSuccess()
    8              0.000002     endif

FUNCTION  coc#float#close_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 773
Called 3 times
Total time:   0.000786
 Self time:   0.000770

count  total (s)   self (s)
    3   0.000026   0.000010   if !coc#float#valid(a:winid)
                                return
    3              0.000001   endif
    3              0.000009   let timer = getwinvar(a:winid, 'timer', 0)
    3              0.000001   if timer
                                call timer_stop(timer)
    3              0.000001   endif
    3              0.000006   let kind = get(a:, 1, '')
    3              0.000007   let winids = getwinvar(a:winid, 'related', [])
    6              0.000007   for id in winids
    3              0.000003     if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
    3              0.000005     elseif nvim_win_is_valid(id)
    3              0.000007       if empty(kind) || getwinvar(id, 'kind', '') ==# kind
    3              0.000648         noa call nvim_win_close(id, 1)
    3              0.000002       endif
    3              0.000001     endif
    6              0.000004   endfor

FUNCTION  coc#helper#min()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\helper.vim line 70
Called 9 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    9              0.000012   let val = a:first
   18              0.000037   for i in range(0, len(a:000) - 1)
    9              0.000014     if a:000[i] < val
    9              0.000012       let val = a:000[i]
    9              0.000004     endif
   18              0.000011   endfor
    9              0.000007   return val

FUNCTION  <SNR>127_syn_name()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\comment.vim line 32
Called 11 times
Total time:   0.001013
 Self time:   0.001013

count  total (s)   self (s)
   11              0.000976   let syn_id = get(synstack(a:lnum, a:cnum), -1)
   11              0.000027   return synIDattr(syn_id, "name")

FUNCTION  gitgutter#process_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 21
Called 15 times
Total time:   4.071094
 Self time:   0.000877

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   15   0.007432   0.000084   if gitgutter#utility#is_active(a:bufnr)
                            
   15              0.000051     if has('patch-7.4.1559')
   15              0.000078       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   15              0.000005     endif
   15   0.000563   0.000094     let how = s:setup_path(a:bufnr, l:Callback)
   15              0.000024     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
   15              0.000005     endif
                            
   15   0.000236   0.000076     if a:force || s:has_fresh_changes(a:bufnr)
                            
    5              0.000005       let diff = 'NOT SET'
    5              0.000003       try
    5   4.062318   0.000076         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    5              0.000004       endtry
                            
    5              0.000010       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    5              0.000003       endif
                            
   15              0.000020     endif
   15              0.000005   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 112
Called 30 times
Total time:   0.000647
 Self time:   0.000327

count  total (s)   self (s)
   30   0.000473   0.000215   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   30   0.000155   0.000094   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>131_handle_double_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 212
Called 5 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    5              0.000018   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    5              0.000002   endif
                            
    5              0.000004   return a:modified_lines

FUNCTION  <SNR>57_unc_path()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 169
Called 5 times
Total time:   0.000612
 Self time:   0.000047

count  total (s)   self (s)
    5   0.000610   0.000045   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>57_is_file_buffer()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 63
Called 15 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   15              0.000062   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  gitgutter#utility#windows()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 236
Called 5 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    5              0.000013   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>84_reset_tick()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter.vim line 166
Called 6 times
Total time:   0.000221
 Self time:   0.000077

count  total (s)   self (s)
    6   0.000216   0.000072   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>105_IsBlock()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 323
Called 4 times
Total time:   0.000372
 Self time:   0.000190

count  total (s)   self (s)
    4   0.000199   0.000016   let tok = s:PreviousToken()
    4              0.000040   if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
    4              0.000008   elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||" ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof') ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
    4              0.000003   elseif tok == '>'
    2              0.000006     return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
    2              0.000001   elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
    2              0.000001   elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
    2              0.000001   elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
    2              0.000008   elseif tok !~ '[=~!<,.?^%|&([]'
    2              0.000029     return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif

FUNCTION  coc#float#content_height()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 749
Called 3 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    3              0.000005   if !bufloaded(a:bufnr)
                                return 0
    3              0.000001   endif
    3              0.000002   if !a:wrap
                                return has('nvim') ? nvim_buf_line_count(a:bufnr) : len(getbufline(a:bufnr, 1, '$'))
    3              0.000001   endif
    3              0.000016   let lines = has('nvim') ? nvim_buf_get_lines(a:bufnr, 0, -1, 0) : getbufline(a:bufnr, 1, '$')
    3              0.000002   let total = 0
    6              0.000007   for line in lines
    3              0.000010     let dw = max([1, strdisplaywidth(line)])
    3              0.000021     let total += float2nr(ceil(str2float(string(dw))/a:width))
    6              0.000004   endfor
    3              0.000002   return total

FUNCTION  <SNR>132_execute()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 292
Called 6 times
Total time:   0.018090
 Self time:   0.005346

count  total (s)   self (s)
    6              0.000012   if has('nvim')
    6   0.018051   0.005308     execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
    6              0.000002   endif

FUNCTION  coc#float#nvim_right_pad()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 281
Called 3 times
Total time:   0.000737
 Self time:   0.000299

count  total (s)   self (s)
    3   0.000048   0.000021   let winid = coc#float#get_related(a:winid, 'pad')
    3              0.000024   let config = { 'relative': a:config['relative'], 'width': 1, 'height': a:config['height'], 'row': a:config['row'], 'col': a:config['col'] + a:config['width'], 'focusable': v:false, 'style': 'minimal', }
    3              0.000002   if winid
                                noa call nvim_win_close(winid, 1)
    3              0.000001   endif
    3   0.000450   0.000039   let bufnr = coc#float#create_buf(0, repeat([''], a:config['height']))
    3              0.000077   let winid = nvim_open_win(bufnr, 0, config)
    3              0.000002   if winid
                                " neovim'bug: the content shown in window could be wired.
    3              0.000042     call setwinvar(winid, '&foldcolumn', 1)
    3              0.000039     call setwinvar(winid, '&winhl', 'FoldColumn:'.a:hlgroup)
    3              0.000008     call setwinvar(winid, 'target_winid', a:winid)
    3              0.000006     call setwinvar(winid, 'kind', 'pad')
    3              0.000005     call add(a:related, winid)
    3              0.000001   endif

FUNCTION  <SNR>105_Balanced()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 247
Called 1 time
Total time:   0.000107
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000001   let l:open = 0
    1              0.000005   let pos = match(a:line, '[][(){}]')
    2              0.000002   while pos != -1
    1   0.000073   0.000035     if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
    1              0.000006       let l:open += matchend(a:line[pos],'[[({]')
    1              0.000001       if l:open < 0
                                    return
    1              0.000000       endif
    1              0.000000     endif
    1              0.000007     let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ? '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
    2              0.000001   endwhile
    1              0.000001   return !l:open

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\comment.vim line 5
Called 11 times
Total time:   0.001637
 Self time:   0.000625

count  total (s)   self (s)
   11              0.000037   let line = getline(".")
   11              0.000016   let col = col('.')
   11              0.000137   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
    1              0.000004     let col = indent('.') + 1
   11              0.000004   endif
   11   0.001128   0.000115   let syn_start = s:syn_name(line('.'), col)
   11              0.000027   let save_cursor = getcurpos()
                            
   11              0.000048   if syn_start =~? '^jsx'
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
   11              0.000004   else
   11              0.000060     let &l:commentstring = a:original
   11              0.000004   endif
                            
                              " Restore the cursor position
   11              0.000027   call setpos('.', save_cursor)

FUNCTION  coc#highlight#add_highlights()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 75
Called 3 times
Total time:   0.019033
 Self time:   0.000115

count  total (s)   self (s)
                              " clear highlights
    3   0.000473   0.000041   call coc#compat#execute(a:winid, 'syntax clear')
    3              0.000006   let bufnr = winbufnr(a:winid)
    3   0.000085   0.000020   call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
    3              0.000003   if !empty(a:codes)
    3   0.018438   0.000018     call coc#highlight#highlight_lines(a:winid, a:codes)
    3              0.000001   endif
    3              0.000005   if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
    3              0.000001   endif

FUNCTION  <SNR>51_hasPrefix()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 217
Called 8 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    8              0.000038     return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix

FUNCTION  gitgutter#diff#run_diff()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 71
Called 5 times
Total time:   4.062242
 Self time:   0.001829

count  total (s)   self (s)
    5   0.000113   0.000030   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
    5              0.000002   endif
                            
    5   0.000125   0.000026   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    5              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    5              0.000005   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    5              0.000017   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    5              0.000010   let s:counter = (s:counter + 1) % 20
    5              0.000014   let buff_file .= '.'.s:counter
                            
    5   0.000762   0.000039   let extension = gitgutter#utility#extension(a:bufnr)
    5              0.000008   if !empty(extension)
    5              0.000011     let buff_file .= '.'.extension
    5              0.000002   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    5   4.037790   0.001070   call s:write_buffer(a:bufnr, buff_file)
                            
    5              0.000015   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    5              0.000033     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    5              0.000013     let from_file .= '.'.s:counter
                            
    5              0.000012     if !empty(extension)
    5              0.000008       let from_file .= '.'.extension
    5              0.000002     endif
                            
                                " Write file from index to temporary file.
    5   0.001265   0.000112     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    5              0.000029     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    5              0.000002   endif
                            
                              " Call git-diff.
    5              0.000014   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    5              0.000004   if s:c_flag
    5              0.000007     let cmd .= ' -c "diff.autorefreshindex=0"'
    5              0.000008     let cmd .= ' -c "diff.noprefix=false"'
    5              0.000007     let cmd .= ' -c "core.safecrlf=false"'
    5              0.000002   endif
    5              0.000021   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    5              0.000010   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    5              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    5              0.000007   let cmd .= ' || exit 0'
                            
    5              0.000006   let cmd .= ')'
                            
    5   0.001473   0.000029   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    5   0.000030   0.000023   if g:gitgutter_async && gitgutter#async#available()
    5   0.020252   0.000066     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    5              0.000008     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  coc#helper#dict_pick()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\helper.vim line 59
Called 3 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    3              0.000004   let res = {}
   21              0.000023   for key in keys(a:dict)
   18              0.000031     if index(a:keys, key) != -1
   15              0.000030       let res[key] = a:dict[key]
   18              0.000007     endif
   21              0.000010   endfor
    3              0.000003   return res

FUNCTION  <SNR>85_convert_config_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 707
Called 3 times
Total time:   0.000257
 Self time:   0.000122

count  total (s)   self (s)
    3              0.000011   let valids = ['relative', 'win', 'anchor', 'width', 'height', 'bufpos', 'col', 'row', 'focusable', 'style']
    3   0.000145   0.000019   let result = coc#helper#dict_pick(a:config, valids)
    3              0.000007   let border = get(a:config, 'border', [])
    3   0.000025   0.000016   if !s:empty_border(border)
                                if result['relative'] ==# 'cursor' && result['row'] < 0
                                  " move top when has bottom border
                                  if get(border, 2, 0)
                                    let result['row'] = result['row'] - 1
                                  endif
                                else
                                  " move down when has top border
                                  if get(border, 0, 0) && !get(a:config, 'prompt', 0)
                                    let result['row'] = result['row'] + 1
                                  endif
                                endif
                                " move right when has left border
                                if get(border, 3, 0)
                                  let result['col'] = result['col'] + 1
                                endif
                                let result['width'] = float2nr(result['width'] + 1 - get(border,3, 0))
    3              0.000001   else
    3              0.000008     let result['width'] = float2nr(result['width'] + 1)
    3              0.000001   endif
    3              0.000007   let result['height'] = float2nr(result['height'])
    3              0.000002   return result

FUNCTION  224()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 148
Called 15 times
Total time:   0.000479
 Self time:   0.000461

count  total (s)   self (s)
   15              0.000029     if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
   15              0.000005     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
   30              0.000078     for w in range(1,winnr('$'))
   15   0.000200   0.000182         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
   15              0.000005         endif
   30              0.000016     endfor
                            
   15              0.000012     return -1

FUNCTION  225()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree\lib\nerdtree\nerdtree.vim line 164
Called 15 times
Total time:   0.000559
 Self time:   0.000080

count  total (s)   self (s)
   15   0.000535   0.000056     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  coc#_complete()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 56
Called 5 times
Total time:   0.002232
 Self time:   0.001748

count  total (s)   self (s)
    5              0.000017   let items = get(g:coc#_context, 'candidates', [])
    5              0.000010   let preselect = get(g:coc#_context, 'preselect', -1)
    5   0.002141   0.001658   call complete( g:coc#_context.start + 1, items)
    5              0.000037   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    5              0.000002   endif
    5              0.000004   return ''

FUNCTION  gitgutter#diff#handler()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 173
Called 5 times
Total time:   0.003580
 Self time:   0.000336

count  total (s)   self (s)
    5   0.000159   0.000028   call gitgutter#debug#log(a:diff)
                            
    5              0.000012   if !bufexists(a:bufnr)
                                return
    5              0.000001   endif
                            
    5   0.001712   0.000059   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    5   0.000810   0.000052   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    5              0.000008   let signs_count = len(modified_lines)
    5              0.000009   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    5              0.000002   else
    5              0.000010     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    5   0.000659   0.000042       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    5              0.000002     endif
    5              0.000002   endif
                            
    5   0.000110   0.000027   call s:save_last_seen_change(a:bufnr)
    5              0.000023   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    5              0.000001   endif

FUNCTION  <SNR>141_syntax_stack_at()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 25
Called 4 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    4              0.000099   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>141_start_col()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 35
Called 8 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    8              0.000086   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  <SNR>105_GetVars()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 49
Called 4 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
    4              0.000173   call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')

FUNCTION  coc#float#nvim_create_related()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 185
Called 3 times
Total time:   0.001020
 Self time:   0.000258

count  total (s)   self (s)
    3              0.000009   let related = getwinvar(a:winid, 'related', [])
    3              0.000005   let exists = !empty(related)
    3              0.000006   let border = get(a:opts, 'border', [])
    3              0.000007   let highlights = get(a:opts, 'borderhighlight', [])
    3              0.000007   let hlgroup = get(a:opts, 'highlight', 'CocFloating')
    3              0.000012   let borderhighlight = type(highlights) == 1 ? highlights : get(highlights, 0, 'CocFloating')
    3   0.000041   0.000023   let borderhighlight =  coc#highlight#compose_hlgroup(borderhighlight, hlgroup)
    3              0.000006   let title = get(a:opts, 'title', '')
    3              0.000006   let buttons = get(a:opts, 'buttons', [])
    3              0.000007   let pad = empty(border) || get(border, 1, 0) == 0
    3              0.000004   if get(a:opts, 'close', 0)
                                call coc#float#nvim_close_btn(a:config, a:winid, border, borderhighlight, related)
    3              0.000002   elseif exists
                                call coc#float#close_related(a:winid, 'close')
    3              0.000001   endif
    3              0.000004   if !empty(buttons)
                                call coc#float#nvim_buttons(a:config, a:winid, buttons, get(border, 2, 0), pad, hlgroup, borderhighlight, related)
    3              0.000002   elseif exists
                                call coc#float#close_related(a:winid, 'buttons')
    3              0.000001   endif
    3   0.000023   0.000016   if !s:empty_border(border)
                                call coc#float#nvim_border_win(a:config, a:winid, border, title, !empty(buttons), borderhighlight, related)
    3              0.000002   elseif exists
                                call coc#float#close_related(a:winid, 'border')
    3              0.000001   endif
                              " Check right border
    3              0.000002   if pad
    3   0.000765   0.000028     call coc#float#nvim_right_pad(a:config, a:winid, hlgroup, related)
                              elseif exists
                                call coc#float#close_related(a:winid, 'pad')
    3              0.000001   endif
    3              0.000019   call setwinvar(a:winid, 'related', filter(related, 'nvim_win_is_valid(v:val)'))

FUNCTION  coc#highlight#clear_highlight()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 49
Called 6 times
Total time:   0.000204
 Self time:   0.000166

count  total (s)   self (s)
    6              0.000038   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    6              0.000010   if !bufloaded(bufnr)
                                return
    6              0.000002   endif
    6   0.000079   0.000041   let src_id = s:create_namespace(a:key)
    6              0.000009   if has('nvim')
    6              0.000033     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
    6              0.000002   endif

FUNCTION  <SNR>130_reset_summary()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 24
Called 5 times
Total time:   0.000083
 Self time:   0.000032

count  total (s)   self (s)
    5   0.000081   0.000030   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  gitgutter#utility#is_active()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 50
Called 15 times
Total time:   0.007347
 Self time:   0.000396

count  total (s)   self (s)
   15   0.007329   0.000378   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>23_Autocmd()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\plugin\coc.vim line 228
Called 102 times
Total time:   0.007814
 Self time:   0.001001

count  total (s)   self (s)
  102              0.000172   if !g:coc_workspace_initialized
                                return
  102              0.000048   endif
  102   0.007352   0.000539   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>59_on_stderr_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 66
Called 5 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    5              0.000010   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    5              0.000002   endif

FUNCTION  coc#highlight#match_ranges()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 152
Called 2 times
Total time:   0.000891
 Self time:   0.000891

count  total (s)   self (s)
    2              0.000027   let winid = a:winid == 0 ? win_getid() : a:winid
    2              0.000007   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    2              0.000018   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    2              0.000001   endif
    2              0.000003   if !s:clear_match_by_window
    2              0.000004     let curr = win_getid()
    2              0.000029     if has('nvim')
    2              0.000038       noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
    2              0.000001     endif
    2              0.000001   endif
    2              0.000003   let ids = []
    9              0.000010   for range in a:ranges
    7              0.000007     let list = []
    7              0.000009     let start = range['start']
    7              0.000007     let end = range['end']
   14              0.000045     for lnum in range(start['line'] + 1, end['line'] + 1)
    7              0.000047       let arr = getbufline(bufnr, lnum)
    7              0.000014       let line = empty(arr) ? '' : arr[0]
    7              0.000008       if empty(line)
                                    continue
    7              0.000003       endif
    7              0.000033       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
    7              0.000045       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
    7              0.000007       if colStart == colEnd
                                    continue
    7              0.000002       endif
    7              0.000018       call add(list, [lnum, colStart, colEnd - colStart])
   14              0.000006     endfor
    7              0.000008     if !empty(list)
    7              0.000016       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
    7              0.000135       let id = matchaddpos(a:hlGroup, list, a:priority, -1, opts)
    7              0.000013       call add(ids, id)
    7              0.000003     endif
    9              0.000005   endfor
    2              0.000002   if !s:clear_match_by_window
    2              0.000026     if has('nvim')
    2              0.000016       noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
    2              0.000015     endif
    2              0.000001   endif
    2              0.000003   return ids

FUNCTION  coc#status()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 123
Called 167 times
Total time:   0.005379
 Self time:   0.004627

count  total (s)   self (s)
  167              0.000884   let info = get(b:, 'coc_diagnostic_info', {})
  167              0.000192   let msgs = []
  167              0.000356   if get(info, 'error', 0)
  119              0.000493     call add(msgs, s:error_sign . info['error'])
  167              0.000084   endif
  167              0.000242   if get(info, 'warning', 0)
                                call add(msgs, s:warning_sign . info['warning'])
  167              0.000060   endif
  167   0.002302   0.001550   return s:trim(join(msgs, ' ') . ' ' . get(g:, 'coc_status', ''))

FUNCTION  <SNR>59_on_exit_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 72
Called 5 times
Total time:   0.003677
 Self time:   0.000097

count  total (s)   self (s)
    5              0.000012   if !a:exit_code
    5   0.003658   0.000078     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    5              0.000002   endif

FUNCTION  <SNR>105_LookingAt()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 165
Called 42 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   42              0.000101   return getline('.')[col('.')-1]

FUNCTION  <SNR>131_highlight_name_for_change()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\sign.vim line 234
Called 28 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   28              0.000025   if a:text ==# 'added'
   28              0.000018     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  271()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\log.vim line 24
Called 8 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    8              0.000016     if a:level < self.level
    8              0.000005         return
                                endif
                                echomsg '[nerdtree-git-status] ' . a:msg

FUNCTION  272()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\log.vim line 31
Called 8 times
Total time:   0.000559
 Self time:   0.000511

count  total (s)   self (s)
    8   0.000554   0.000506     echohl LineNr | call self.output(s:debug, a:msg) | echohl None

FUNCTION  coc#util#set_buf_var()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\util.vim line 842
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000026   if !bufloaded(a:bufnr) | return | endif
    3              0.000013   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  <SNR>57_dos_shell()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 173
Called 5 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    5              0.000013   return &shell == 'cmd.exe' || &shell == 'command.com'

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 765
Called 11 times
Total time:   0.000321
 Self time:   0.000190

count  total (s)   self (s)
   11   0.000267   0.000137   let id = coc#float#get_related(a:winid, 'scrollbar')
   11              0.000017   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
   11              0.000004   endif

FUNCTION  <SNR>128_process_hunk()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 240
Called 5 times
Total time:   0.000614
 Self time:   0.000252

count  total (s)   self (s)
    5              0.000005   let modifications = []
    5              0.000006   let from_line  = a:hunk[0]
    5              0.000006   let from_count = a:hunk[1]
    5              0.000005   let to_line    = a:hunk[2]
    5              0.000005   let to_count   = a:hunk[3]
                            
    5   0.000033   0.000024   if s:is_added(from_count, to_count)
    5   0.000208   0.000032     call s:process_added(modifications, from_count, to_count, to_line)
    5   0.000208   0.000032     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    5              0.000001   endif
    5              0.000004   return modifications

FUNCTION  <SNR>57_dir()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 214
Called 20 times
Total time:   0.003131
 Self time:   0.000276

count  total (s)   self (s)
   20   0.003122   0.000267   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>105_SynAt()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 84
Called 5 times
Total time:   0.000401
 Self time:   0.000401

count  total (s)   self (s)
    5              0.000015   let byte = line2byte(a:l) + a:c - 1
    5              0.000010   let pos = index(s:synid_cache[0], byte)
    5              0.000003   if pos == -1
    5              0.000357     let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
    5              0.000003   endif
    5              0.000007   return s:synid_cache[1][pos]

FUNCTION  gitstatus#util#UpdateParentDirsStatus()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 203
Called 8 times
Total time:   0.000307
 Self time:   0.000307

count  total (s)   self (s)
    8              0.000029     let l:dirtyPath = fnamemodify(a:pathStr, ':h')
    8              0.000020     let l:dir_dirty_only = get(a:opts, 'NERDTreeGitStatusDirDirtyOnly', 1)
   16              0.000025     while l:dirtyPath !=# a:root
    8              0.000017         let l:key = get(a:cache, l:dirtyPath, '')
    8              0.000007         if l:dir_dirty_only
    8              0.000007             if l:key ==# ''
    8              0.000015                 let a:cache[l:dirtyPath] = 'Dirty'
                                        else
                                            return
    8              0.000003             endif
                                    else
                                        if l:key ==# ''
                                            let a:cache[l:dirtyPath] = a:statusKey
                                        elseif l:key ==# 'Dirty' || l:key ==# a:statusKey
                                            return
                                        else
                                            let a:cache[l:dirtyPath] = 'Dirty'
                                        endif
    8              0.000003         endif
    8              0.000021         let l:dirtyPath = fnamemodify(l:dirtyPath, ':h')
   16              0.000012     endwhile

FUNCTION  281()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 65
Called 8 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    8              0.000017     let self.next = a:cache

FUNCTION  285()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\listener.vim line 81
Called 8 times
Total time:   0.000301
 Self time:   0.000038

count  total (s)   self (s)
    8   0.000292   0.000029     if !g:NERDTree.IsOpen()
    8              0.000004         return
                                endif
                            
                                if !self.changed()
                                    return
                                endif
                            
                                call self.update()
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                try
                                    call g:NERDTree.CursorToTreeWin()
                                    call b:NERDTree.root.refreshFlags()
                                    call NERDTreeRender()
                                finally
                                    noautocmd exec l:altwinnr . 'wincmd w'
                                    noautocmd exec l:winnr . 'wincmd w'
                                endtry

FUNCTION  289()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 37
Called 16 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
   16              0.000079     let self.chunks[-1] .= a:data[0]
   16              0.000059     call extend(self.chunks, a:data[1:])

FUNCTION  <SNR>128_save_last_seen_change()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\diff.vim line 415
Called 5 times
Total time:   0.000083
 Self time:   0.000032

count  total (s)   self (s)
    5   0.000081   0.000030   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>105_Continues()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 236
Called 2 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000035   let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
    2              0.000007   if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
    2              0.000004   elseif tok !~ '[/>]'
    2              0.000002     return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')

FUNCTION  coc#rpc#notify()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\rpc.vim line 95
Called 111 times
Total time:   0.007428
 Self time:   0.001447

count  total (s)   self (s)
  111   0.001138   0.000465   if !coc#rpc#ready()
                                return ''
  111              0.000051   endif
  111   0.006010   0.000701   call s:client['notify'](a:method, a:args)
  111              0.000073   return ''

FUNCTION  coc#float#valid()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 175
Called 9 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    9              0.000008   if a:winid <= 0
                                return 0
    9              0.000003   endif
    9              0.000016   if has('nvim')
    9              0.000025     return nvim_win_is_valid(a:winid) ? 1 : 0
                              endif
                              return s:popup_visible(a:winid)

FUNCTION  <SNR>59_on_stdout_nvim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\async.vim line 56
Called 10 times
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
   10              0.000090   if empty(self.stdoutbuffer)
    5              0.000019     let self.stdoutbuffer = a:data
    5              0.000003   else
    5              0.000086     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   10              0.000007   endif

FUNCTION  <SNR>86_trim()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc.vim line 135
Called 167 times
Total time:   0.000752
 Self time:   0.000752

count  total (s)   self (s)
  167              0.000310   if exists('*trim')
  167              0.000296     return trim(a:str)
                              endif
                              return substitute(a:str, '\s\+$', '', '')

FUNCTION  coc#highlight#highlight_lines()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\highlight.vim line 101
Called 3 times
Total time:   0.018420
 Self time:   0.000330

count  total (s)   self (s)
    3              0.000005   let currwin = win_getid()
    3              0.000006   if has('nvim') && currwin != a:winid
    3              0.000014     noa call nvim_set_current_win(a:winid)
    3              0.000001   endif
    3              0.000003   let defined = []
    3              0.000002   let region_id = 1
    6              0.000007   for config in a:blocks
    3              0.000005     let start = config['startLine'] + 1
    3              0.000031     let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
    3              0.000006     let filetype = get(config, 'filetype', '')
    3              0.000005     let hlGroup = get(config, 'hlGroup', '')
    3              0.000004     if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
    3              0.000001     else
    3              0.000020       let filetype = matchstr(filetype, '\v[^.]*')
    3              0.000005       if index(defined, filetype) == -1
    3   0.018076   0.000028         call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
    3              0.000009         call add(defined, filetype)
    3              0.000001       endif
    3   0.000083   0.000040       call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype))
    3              0.000005       let region_id = region_id + 1
    3              0.000001     endif
    6              0.000005   endfor
    3              0.000005   if has('nvim')
    3              0.000038     noa call nvim_set_current_win(currwin)
    3              0.000001   endif

FUNCTION  290()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 42
Called 8 times
Total time:   0.000241
 Self time:   0.000186

count  total (s)   self (s)
    8   0.000188   0.000133     let self.failed = self.failed || !s:isEOF(a:data)
    8              0.000022     let self.err_chunks[-1] .= a:data[0]
    8              0.000022     call extend(self.err_chunks, a:data[1:])

FUNCTION  293()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 63
Called 8 times
Total time:   0.001900
 Self time:   0.000097

count  total (s)   self (s)
    8              0.000019     if has_key(self.opts, 'on_success_cb')
    8   0.001871   0.000068         call call(self.opts.on_success_cb, [self])
    8              0.000003     endif

FUNCTION  294()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 70
Called 8 times
Total time:   0.023933
 Self time:   0.023933

count  total (s)   self (s)
    8              0.023736         let jid = jobstart(a:cmd, { 'on_stdout': {_job_id, data, _event  -> self.onStdoutCB(data)}, 'on_stderr': {_job_id, data, _event  -> self.onStderrCB(data)}, 'on_exit':   {_job_id, _data, _event -> self.onExitCB()}, 'env':       {'GIT_OPTIONAL_LOCKS': '0'}, })
    8              0.000045         let self.id = jid
    8              0.000013         let self.running = jid > 0
    8              0.000008         if jid <= 0
                                        let self.failed = 1
                                        let self.err_chunks = jid == 0 ? ['invalid arguments'] : ['command is not executable']
                                        call self.onExitCB()
    8              0.000005         endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 21
Called 68 times
Total time:   0.000610
 Self time:   0.000610

count  total (s)   self (s)
   68              0.000186   let ggvars = getbufvar(a:buffer, 'gitgutter')
   68              0.000258   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   53              0.000068     return ggvars[a:varname]
   15              0.000005   endif
   15              0.000008   if a:0
   15              0.000010     return a:1
                              endif

FUNCTION  <SNR>57_not_git_dir()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\utility.vim line 59
Called 15 times
Total time:   0.002629
 Self time:   0.000191

count  total (s)   self (s)
   15   0.002620   0.000182   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>99_newJob()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\job.vim line 30
Called 8 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    8              0.000155     return extend(deepcopy(s:Job), { 'name': a:name, 'opts': a:opts })

FUNCTION  GetJavascriptIndent()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 350
Called 4 times
Total time:   0.004252
 Self time:   0.002050

count  total (s)   self (s)
    4   0.000207   0.000032   call s:GetVars()
    4              0.000024   let s:synid_cache = [[],[]]
    4              0.000027   let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
    4              0.000078   let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
    4              0.000026   if s:stack[-1] =~? 'comment\|doc'
                                if l:line !~ '^\s*\/[/*]'
                                  return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
                                endif
    4              0.000054   elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
    4              0.000001   endif
                            
    4              0.000030   let nest = get(get(b:,'hi_indent',{}),'blocklnr')
    4              0.000015   let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
    4              0.000006   call cursor(v:lnum,1)
    4   0.000278   0.000035   if s:PreviousToken() is ''
                                return
    4              0.000001   endif
    4              0.000022   let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
                            
    4              0.000022   let l:line = substitute(l:line,'^\s*','','')
    4              0.000020   let l:line_s = l:line[0]
    4              0.000004   if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
    4              0.000001   endif
    4              0.000030   if l:line =~ '^\/[/*]'
                                let l:line = ''
    4              0.000001   endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    4              0.000006   call cursor(v:lnum,1)
    4              0.000032   let idx = index([']',')','}'],l:line[0])
    4   0.000125   0.000018   if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum || b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
    1              0.000002     call call('cursor',b:js_cache[1:])
    3              0.000001   else
    3              0.000807     let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0, max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
    3              0.000003     try
    3              0.000002       if idx != -1
    1   0.000127   0.000021         call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
    2              0.000018       elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
    2   0.000131   0.000012         if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
                                      return indent(l:lnum)
    2              0.000001         endif
                                  else
                                    call s:AlternatePair()
    3              0.000001       endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
    3              0.000002     endtry
    3              0.000012     let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
    4              0.000001   endif
                            
    4              0.000023   let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
    4   0.000049   0.000043   let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
    4   0.000409   0.000029   if !num || s:LookingAt() == '{' && s:IsBlock()
    4              0.000006     let ilnum = line('.')
    4   0.000325   0.000027     if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
    2              0.000002       if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
    2              0.000001       endif
    2              0.000005       if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
    2              0.000001       endif
    4              0.000001     endif
    4              0.000009     if idx == -1 && pline[-1:] !~ '[{;]'
    2              0.000004       call cursor(l:lnum, lcol)
    2              0.000021       let sol = matchstr(l:line,s:opfirst)
    2              0.000007       if sol is '' || sol == '/' && s:SynAt(v:lnum, 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
    2   0.000061   0.000007         if s:Continues()
                                      let is_op = s:sw()
    2              0.000001         endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' && s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) && s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) && (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' && s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
    2              0.000001       endif
    2              0.000003       call cursor(l:lnum, lcol)
    2   0.000734   0.000025       let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
    4              0.000001     endif
                              elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
    4              0.000001   endif
                            
                              " main return
    4              0.000037   if l:line =~ '^[])}]\|^|}'
    2              0.000002     if l:line_s == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
    2              0.000000     endif
    2              0.000015     return num_ind
    2              0.000001   elseif num
    2   0.000020   0.000015     return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              elseif nest
                                return indent(nextnonblank(nest+1)) + b_l + is_op
                              endif
                              return b_l + is_op

FUNCTION  coc#float#nvim_scrollbar()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\coc.nvim\autoload\coc\float.vim line 351
Called 3 times
Total time:   0.000360
 Self time:   0.000172

count  total (s)   self (s)
    3   0.000050   0.000025   if !has('nvim-0.4.0') || !coc#float#valid(a:winid) || getwinvar(a:winid, 'target_winid', 0)
                                return
    3              0.000001   endif
    3              0.000015   let config = nvim_win_get_config(a:winid)
    3              0.000011   let [row, column] = nvim_win_get_position(a:winid)
    3              0.000006   let width = nvim_win_get_width(a:winid)
    3              0.000005   let height = nvim_win_get_height(a:winid)
    3              0.000005   let bufnr = winbufnr(a:winid)
    3              0.000010   let cw = getwinvar(a:winid, '&foldcolumn', 0) ? width - 1 : width
    3   0.000127   0.000024   let ch = coc#float#content_height(bufnr, cw, getwinvar(a:winid, '&wrap'))
    3   0.000049   0.000015   let closewin = coc#float#get_related(a:winid, 'close')
    3              0.000006   let border = getwinvar(a:winid, 'border', [])
    3              0.000005   let move_down = closewin && !get(border, 0, 0)
    3              0.000002   if move_down
                                let height = height - 1
    3              0.000001   endif
    3   0.000039   0.000012   let id = coc#float#get_related(a:winid, 'scrollbar')
    3              0.000003   if ch <= height || height <= 0
                                " no scrollbar, remove exists
    3              0.000002     if id
                                  call s:close_win(id)
    3              0.000001     endif
    3              0.000001     return
                              endif
                              call coc#float#close_related(a:winid, 'pad')
                              let sbuf = id ? winbufnr(id) : 0
                              let sbuf = coc#float#create_buf(sbuf, repeat([' '], height))
                              let opts = { 'row': move_down ? row + 1 : row, 'col': column + width, 'relative': 'editor', 'width': 1, 'height': height, 'focusable': v:false, 'style': 'minimal', }
                              if id
                                call nvim_win_set_config(id, opts)
                              else
                                let id = nvim_open_win(sbuf, 0 , opts)
                                if id == 0
                                  return
                                endif
                                call setwinvar(id, 'kind', 'scrollbar')
                                call setwinvar(id, 'target_winid', a:winid)
                              endif
                              let thumb_height = max([1, float2nr(floor(height * (height + 0.0)/ch))])
                              let wininfo = getwininfo(a:winid)[0]
                              let start = 0
                              if wininfo['topline'] != 1
                                " needed for correct getwininfo
                                let firstline = wininfo['topline']
                                let lastline = s:nvim_get_botline(firstline, height, cw, bufnr)
                                let linecount = nvim_buf_line_count(winbufnr(a:winid))
                                if lastline >= linecount
                                  let start = height - thumb_height
                                else
                                  let start = max([1, float2nr(round((height - thumb_height + 0.0)*(firstline - 1.0)/(ch - height)))])
                                endif
                              endif
                              " add highlights
                              call nvim_buf_clear_namespace(sbuf, -1, 0, -1)
                              for idx in range(0, height - 1)
                                if idx >= start && idx < start + thumb_height
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuThumb', idx, 0, 1)
                                else
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuSbar', idx, 0, 1)
                                endif
                              endfor
                              call s:add_related(id, a:winid)

FUNCTION  <SNR>141_is_jsx_backticks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\autoload\jsx_pretty\indent.vim line 96
Called 4 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    4              0.000037   return a:syntax =~? 'jsxBackticks'

FUNCTION  <SNR>105_Pure()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-polyglot\indent\javascript.vim line 198
Called 2 times
Total time:   0.000106
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000106   0.000018   return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")

FUNCTION  gitstatus#util#ParseGitStatusLines()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\autoload\gitstatus\util.vim line 82
Called 8 times
Total time:   0.001170
 Self time:   0.000467

count  total (s)   self (s)
    8              0.000011     let l:result = {}
    8              0.000008     let l:is_rename = 0
   16              0.000023     for l:line in a:statusLines
    8              0.000007         if l:is_rename
                                        call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, a:root . '/' . l:line, 'Dirty', a:opts)
                                        let l:is_rename = 0
                                        continue
    8              0.000003         endif
    8   0.000488   0.000091         let [l:pathStr, l:statusKey] = gitstatus#util#ParseGitStatusLine(l:line, a:opts)
                            
    8              0.000017         let l:pathStr = a:root . '/' . l:pathStr
    8              0.000013         if l:pathStr[-1:-1] is# '/'
                                        let l:pathStr = l:pathStr[:-2]
    8              0.000003         endif
    8              0.000012         let l:is_rename = l:statusKey is# 'Renamed'
    8              0.000019         let l:result[l:pathStr] = l:statusKey
                            
    8   0.000373   0.000067         call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, l:pathStr, l:statusKey, a:opts)
   16              0.000011     endfor
    8              0.000006     return l:result

FUNCTION  <SNR>51_onFileUpdate()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\nerdtree-git-plugin\nerdtree_plugin\git_status.vim line 205
Called 1 time
Total time:   0.002912
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000009     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
    1   0.000016   0.000010     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    1              0.000000     endif
    1   0.002796   0.000008     let l:job = s:refreshGitStatus('file-update', g:NTGitWorkdir)
    1   0.000088   0.000015     call s:logger.debug('run file-update job: ' . l:job.id)

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: C:\Program Files\Neovim\share\nvim\plugged\vim-gitgutter\autoload\gitgutter\hunk.vim line 5
Called 5 times
Total time:   0.000217
 Self time:   0.000065

count  total (s)   self (s)
    5   0.000102   0.000033   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    5   0.000112   0.000029   call s:reset_summary(a:bufnr)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   15   4.071094   0.000877  gitgutter#process_buffer()
    5   4.062242   0.001829  gitgutter#diff#run_diff()
    5   4.036719             <SNR>128_write_buffer()
    8   0.266289   0.000118  coc#rpc#request()
    8   0.266124   0.264905  <SNR>26_request()
    1   0.258823   0.000017  <SNR>23_SyncAutocmd()
    2   0.090106   0.002316  gitgutter#all()
    3   0.032981   0.010944  coc#float#create_pum_float()
    8   0.024679   0.000224  <SNR>51_refreshGitStatus()
    8   0.024218   0.000125  gitstatus#job#Spawn()
    8   0.023933             294()
    7   0.022795   0.000382  <SNR>51_onCursorHold()
    5   0.020185   0.020017  gitgutter#async#execute()
    3   0.019033   0.000115  coc#highlight#add_highlights()
    3   0.018420   0.000330  coc#highlight#highlight_lines()
    6   0.018090   0.005346  <SNR>132_execute()
   47   0.014879             <SNR>74_Highlight_Matching_Pair()
  102   0.007814   0.001001  <SNR>23_Autocmd()
  111   0.007428   0.001447  coc#rpc#notify()
   15   0.007347   0.000396  gitgutter#utility#is_active()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    5              4.036719  <SNR>128_write_buffer()
    8   0.266124   0.264905  <SNR>26_request()
    8              0.023933  294()
    5   0.020185   0.020017  gitgutter#async#execute()
   47              0.014879  <SNR>74_Highlight_Matching_Pair()
    3   0.032981   0.010944  coc#float#create_pum_float()
   45              0.006588  <SNR>57_abs_path()
    6   0.018090   0.005346  <SNR>132_execute()
  111   0.005309   0.004870  <SNR>26_notify()
  167   0.005379   0.004627  coc#status()
    2   0.090106   0.002316  gitgutter#all()
    4   0.004252   0.002050  GetJavascriptIndent()
   12   0.002441   0.001869  coc#highlight#ranges()
    5   4.062242   0.001829  gitgutter#diff#run_diff()
    5   0.002232   0.001748  coc#_complete()
  111   0.007428   0.001447  coc#rpc#notify()
    3              0.001079  coc#util#get_complete_option()
   15   0.004054   0.001021  <SNR>57_exists_file()
   11              0.001013  <SNR>127_syn_name()
  102   0.007814   0.001001  <SNR>23_Autocmd()

